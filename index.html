<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="referrer" content="no-referrer">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MangaTrack v16</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700;900&family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300&family=Bebas+Neue&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0f;
  --surface: #111118;
  --card: #15151e;
  --border: #252535;
  --accent: #e8385a;
  --accent2: #ff9f43;
  --accent3: #00d2d3;
  --text: #e8e8f0;
  --muted: #5c5c7a;
  --success: #26de81;
}
body.light {
  --bg: #f0f0f5;
  --surface: #e4e4ec;
  --card: #ffffff;
  --border: #d0d0e0;
  --accent: #d42e50;
  --accent2: #e08800;
  --accent3: #009fa0;
  --text: #1a1a2e;
  --muted: #7070a0;
  --success: #18b860;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'DM Mono', monospace;
  min-height: 100vh;
  transition: background .25s, color .25s;
}
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(ellipse 60% 40% at 15% 15%, rgba(232,56,90,.07) 0%, transparent 60%),
    radial-gradient(ellipse 50% 40% at 85% 85%, rgba(0,210,211,.05) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}
.wrap { max-width: 1200px; margin: 0 auto; padding: 0 24px; position: relative; z-index: 1; }

header { padding: 28px 0 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; }
.logo-title { font-family: 'Bebas Neue', sans-serif; font-size: 40px; letter-spacing: 5px; line-height: 1; }
.logo-title span { color: var(--accent); }
.logo-sub { font-size: 9px; color: var(--muted); letter-spacing: 3px; text-transform: uppercase; margin-top: 2px; }
.header-right { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

.btn {
  font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 2px;
  text-transform: uppercase; padding: 9px 18px; cursor: pointer; border: none;
  transition: all .2s; display: inline-flex; align-items: center; gap: 7px;
}
.btn-outline { background: transparent; border: 1px solid var(--border); color: var(--muted); }
.btn-outline:hover { border-color: var(--accent3); color: var(--accent3); }
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: #ff1f44; transform: translateY(-1px); }
.btn-sm { padding: 6px 12px; font-size: 9px; }
.btn.spinning .spin-icon { animation: spin .6s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
.spin-icon { display: inline-block; }

.stats { display: flex; gap: 28px; padding: 16px 0; border-bottom: 1px solid var(--border); flex-wrap: wrap; }
.stat { display: flex; flex-direction: column; gap: 2px; }
.stat-val { font-family: 'Bebas Neue', sans-serif; font-size: 30px; line-height: 1; }
.c1{color:var(--text)} .c2{color:var(--accent3)} .c3{color:var(--accent2)} .c4{color:var(--accent)}
.stat-label { font-size: 9px; color: var(--muted); letter-spacing: 2px; text-transform: uppercase; }

.tabs { display: flex; border-bottom: 1px solid var(--border); }
.tab { background: none; border: none; color: var(--muted); font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; padding: 14px 18px; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -1px; transition: all .2s; }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab:hover:not(.active) { color: var(--text); }
.tab-badge { display: inline-block; background: var(--accent3); color: #000; font-size: 8px; padding: 1px 5px; border-radius: 999px; margin-left: 4px; vertical-align: middle; font-weight: 700; }

.toolbar { display: flex; gap: 10px; padding: 18px 0; align-items: center; flex-wrap: wrap; }
.search-wrap { position: relative; flex: 1; min-width: 180px; }
.search-wrap input { width: 100%; background: var(--surface); border: 1px solid var(--border); color: var(--text); padding: 9px 14px 9px 34px; font-family: 'DM Mono', monospace; font-size: 11px; outline: none; transition: border-color .2s; -webkit-appearance: none; appearance: none; }
.search-wrap input::-webkit-search-cancel-button { display: none; }
.search-wrap input:focus { border-color: var(--accent); }
.search-wrap input::placeholder { color: var(--muted); }
.search-icon { position: absolute; left: 11px; top: 50%; transform: translateY(-50%); color: var(--muted); font-size: 13px; pointer-events: none; }
.flt { background: var(--surface); border: 1px solid var(--border); color: var(--text); padding: 9px 12px; font-family: 'DM Mono', monospace; font-size: 10px; outline: none; cursor: pointer; letter-spacing: 1px; }

.grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px; padding-bottom: 60px; }
.card { background: var(--card); border: 1px solid var(--border); position: relative; overflow: hidden; transition: all .22s; animation: fadeUp .3s ease both; }
@keyframes fadeUp { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:translateY(0)} }
.card:hover { border-color: var(--accent); transform: translateY(-2px); box-shadow: 0 10px 40px rgba(232,56,90,.12); }
.card.has-new { border-color: var(--accent3); }
.card.has-new::after { content:''; position:absolute; top:0; left:0; right:0; height:2px; background:var(--accent3); }
.new-pill { position:absolute; top:10px; right:10px; background:var(--accent3); color:#000; font-size:8px; font-weight:700; padding:2px 8px; letter-spacing:2px; text-transform:uppercase; animation:glow 2s infinite; }
@keyframes glow { 0%,100%{box-shadow:0 0 6px rgba(0,210,211,.5)} 50%{box-shadow:0 0 14px rgba(0,210,211,.9)} }
.card-cover { width:100%; height:150px; object-fit:cover; display:block; background:var(--surface); }
.cover-ph { width:100%; height:150px; background:linear-gradient(135deg,var(--surface),var(--border)); display:flex; align-items:center; justify-content:center; font-family:'Noto Serif JP',serif; font-size:52px; color:var(--border); }
.card-body { padding:12px 14px; }
.card-type { font-size:8px; letter-spacing:3px; text-transform:uppercase; margin-bottom:5px; }
.type-manga{color:var(--accent)} .type-manhua{color:var(--accent2)} .type-manhwa{color:var(--accent3)}
.card-title { font-family:'Noto Serif JP',serif; font-size:14px; font-weight:700; line-height:1.35; margin-bottom:10px; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }
.card-meta { display:flex; justify-content:space-between; align-items:flex-start; gap:8px; }
.card-actions { display:grid; grid-template-columns:1fr 1fr; gap:5px; width:80px; flex-shrink:0; }
.ch-read { font-size:10px; color:var(--muted); }
.ch-latest { font-size:12px; color:var(--text); margin-top:2px; }
.ch-latest.new { color:var(--accent3); }
.card-actions { display:grid; grid-template-columns:1fr 1fr; gap:5px; }
.icon-btn { background:var(--surface); border:1px solid var(--border); color:var(--muted); width:100%; height:34px; padding:0 6px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:14px; transition:all .15s; flex-shrink:0; }
.icon-btn:hover { border-color:var(--accent); color:var(--accent); }
.icon-btn.del:hover { border-color:#f55; color:#f55; }
.plus-one { background:var(--surface); border:1px solid var(--border); color:var(--muted); width:100%; height:34px; padding:0 12px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:12px; letter-spacing:1px; transition:all .15s; flex-shrink:0; font-family:'DM Mono',monospace; }
.card-foot { margin-top:8px; font-size:9px; color:var(--muted); display:flex; align-items:center; gap:5px; }
.dot { width:6px; height:6px; border-radius:50%; flex-shrink:0; }
.dot.ongoing{background:var(--accent3)} .dot.completed{background:var(--muted)} .dot.hiatus{background:var(--accent2)} .dot.cancelled{background:#f55}
.card-source { font-size:8px; color:var(--muted); opacity:.5; margin-top:3px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; letter-spacing:.5px; }

/* +1 chapter button */
.plus-one:hover { border-color:var(--accent3); color:var(--accent3); background:rgba(0,210,211,.08); }
.plus-one:active { transform:scale(.95); }

/* chapters-behind badge */
.behind-badge { display:inline-block; background:rgba(232,56,90,.15); color:var(--accent); font-size:8px; padding:2px 6px; letter-spacing:1px; margin-left:4px; border:1px solid rgba(232,56,90,.25); }

/* duplicate warning in add modal */
.dup-warning { background:rgba(255,159,67,.1); border:1px solid rgba(255,159,67,.4); border-left:3px solid var(--accent2); padding:8px 12px; font-size:10px; color:var(--accent2); display:none; }

/* suggestions panel */
.suggest-panel { display:none; padding-bottom:60px; }
.suggest-panel.active { display:block; }
.suggest-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:12px; padding:16px 0 60px; }
.suggest-card { background:var(--card); border:1px solid var(--border); overflow:hidden; cursor:pointer; transition:all .2s; animation:fadeUp .3s ease both; }
.suggest-card:hover { border-color:var(--accent3); transform:translateY(-2px); box-shadow:0 8px 30px rgba(0,210,211,.1); }
.suggest-cover { width:100%; height:130px; object-fit:cover; display:block; background:var(--surface); }
.suggest-ph { width:100%; height:130px; background:linear-gradient(135deg,var(--surface),var(--border)); display:flex; align-items:center; justify-content:center; font-size:42px; color:var(--border); }
.suggest-body { padding:10px 12px; }
.suggest-title { font-family:'Noto Serif JP',serif; font-size:12px; font-weight:700; line-height:1.3; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; margin-bottom:5px; }
.suggest-meta { font-size:9px; color:var(--muted); letter-spacing:1px; }
.suggest-add { width:100%; margin-top:8px; background:var(--surface); border:1px solid var(--border); color:var(--muted); font-family:'DM Mono',monospace; font-size:9px; letter-spacing:2px; padding:6px; cursor:pointer; text-transform:uppercase; transition:all .15s; }
.suggest-add:hover { border-color:var(--accent3); color:var(--accent3); }
.suggest-loading { text-align:center; padding:60px 20px; color:var(--muted); font-size:10px; letter-spacing:2px; animation:pulse 1s infinite; }

.empty { grid-column:1/-1; text-align:center; padding:80px 24px; }
.empty-icon { font-size:60px; opacity:.15; margin-bottom:14px; }
.empty-title { font-family:'Bebas Neue',sans-serif; font-size:26px; letter-spacing:4px; color:var(--muted); margin-bottom:6px; }
.empty-sub { font-size:10px; color:var(--muted); letter-spacing:1px; }

.overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,.85); z-index:200; backdrop-filter:blur(6px); align-items:center; justify-content:center; padding:20px; }
.overlay.open { display:flex; }
.modal { background:var(--card); border:1px solid var(--border); width:100%; max-width:520px; animation:slideUp .25s ease; max-height:90vh; overflow-y:auto; }
@keyframes slideUp { from{opacity:0;transform:translateY(20px)} to{opacity:1;transform:translateY(0)} }
.modal-hd { padding:18px 22px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; position:sticky; top:0; background:var(--card); z-index:2; }
.modal-title { font-family:'Bebas Neue',sans-serif; font-size:22px; letter-spacing:3px; }
.close-btn { background:none; border:none; color:var(--muted); font-size:18px; cursor:pointer; transition:color .15s; }
.close-btn:hover { color:var(--accent); }
.modal-body { padding:20px 22px; display:flex; flex-direction:column; gap:14px; }
.form-group { display:flex; flex-direction:column; gap:5px; }
.form-label { font-size:9px; letter-spacing:2px; text-transform:uppercase; color:var(--muted); }
.form-input, .form-select { background:var(--surface); border:1px solid var(--border); color:var(--text); padding:9px 12px; font-family:'DM Mono',monospace; font-size:11px; outline:none; width:100%; transition:border-color .2s; }
.form-input:focus,.form-select:focus { border-color:var(--accent); }
.form-input::placeholder { color:var(--muted); }
.form-row { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
.modal-ft { padding:14px 22px; border-top:1px solid var(--border); display:flex; justify-content:flex-end; gap:8px; position:sticky; bottom:0; background:var(--card); }

.md-results { border:1px solid var(--border); border-top:none; background:var(--surface); max-height:220px; overflow-y:auto; display:none; }
.md-results.open { display:block; }
.sr-item { display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border); transition:background .15s; }
.sr-item:last-child { border-bottom:none; }
.sr-item:hover { background:var(--card); }
.sr-thumb { width:36px; height:48px; object-fit:cover; background:var(--border); flex-shrink:0; }
.sr-ph { width:36px; height:48px; background:var(--border); display:flex; align-items:center; justify-content:center; font-size:16px; flex-shrink:0; }
.sr-info { flex:1; min-width:0; }
.sr-name { font-size:12px; font-weight:500; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.sr-meta { font-size:9px; color:var(--muted); margin-top:2px; letter-spacing:1px; text-transform:uppercase; }
.sr-msg { padding:14px; text-align:center; color:var(--muted); font-size:10px; letter-spacing:2px; }
.sr-msg.loading { animation:pulse 1s infinite; }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.4} }

.update-panel { display:none; padding-bottom:60px; }
.update-panel.active { display:block; }
.log-toolbar { display:flex; align-items:center; justify-content:space-between; padding:16px 0 12px; }
.log-label { font-size:9px; letter-spacing:2px; color:var(--muted); text-transform:uppercase; }
.log-entry { display:flex; align-items:center; gap:14px; border-left:2px solid var(--border); padding:12px 18px; margin-bottom:10px; background:var(--card); transition:border-color .2s; }
.log-entry.unread { border-left-color:var(--accent3); }
.log-cover { width:36px; height:48px; object-fit:cover; background:var(--border); flex-shrink:0; }
.log-cover-ph { width:36px; height:48px; background:linear-gradient(135deg,var(--surface),var(--border)); display:flex; align-items:center; justify-content:center; font-size:16px; flex-shrink:0; }
.log-info { flex:1; min-width:0; }
.log-title-txt { font-family:'Noto Serif JP',serif; font-size:13px; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.log-ch { font-size:11px; color:var(--accent3); margin-top:3px; }
.log-time { font-size:9px; color:var(--muted); text-align:right; white-space:nowrap; }

.toast { position:fixed; bottom:24px; right:24px; background:var(--accent3); color:#000; padding:11px 20px; font-size:10px; letter-spacing:1.5px; font-weight:600; z-index:999; transform:translateY(70px); opacity:0; transition:all .3s; text-transform:uppercase; max-width:340px; }
.toast.show { transform:translateY(0); opacity:1; }
.toast.err { background:var(--accent); color:#fff; }

.info-note { background:var(--surface); border:1px solid var(--border); border-left:3px solid var(--accent3); padding:10px 14px; font-size:10px; color:var(--muted); line-height:1.6; letter-spacing:.5px; }
.info-note strong { color:var(--accent3); }

/* Import/Export */
.ie-tabs { display:flex; gap:0; border-bottom:1px solid var(--border); margin-bottom:16px; }
.ie-tab { background:none; border:none; border-bottom:2px solid transparent; color:var(--muted); font-family:'DM Mono',monospace; font-size:10px; letter-spacing:2px; text-transform:uppercase; padding:10px 16px; cursor:pointer; margin-bottom:-1px; transition:all .2s; }
.ie-tab.active { color:var(--accent3); border-bottom-color:var(--accent3); }
.ie-panel { display:none; } .ie-panel.active { display:flex; flex-direction:column; gap:12px; }
.drop-zone { border:2px dashed var(--border); padding:30px; text-align:center; cursor:pointer; transition:all .2s; color:var(--muted); font-size:10px; letter-spacing:1px; }
.drop-zone:hover,.drop-zone.drag-over { border-color:var(--accent3); color:var(--accent3); }
.drop-zone input { display:none; }
.drop-icon { font-size:32px; margin-bottom:8px; }
.import-preview { background:var(--surface); border:1px solid var(--border); max-height:180px; overflow-y:auto; }
.preview-row { display:flex; align-items:center; gap:8px; padding:7px 12px; border-bottom:1px solid var(--border); font-size:10px; }
.preview-row:last-child { border-bottom:none; }
.preview-status { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
.ps-ok{background:var(--success)} .ps-dup{background:var(--accent2)} .ps-err{background:var(--accent)}
.preview-title { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.preview-meta { color:var(--muted); font-size:9px; white-space:nowrap; }
.export-opt { display:flex; gap:8px; flex-wrap:wrap; }
.textarea-raw { background:var(--surface); border:1px solid var(--border); color:var(--text); padding:10px 12px; font-family:'DM Mono',monospace; font-size:10px; width:100%; min-height:120px; outline:none; resize:vertical; line-height:1.6; }
.textarea-raw:focus { border-color:var(--accent3); }
.import-progress { font-size:10px; color:var(--accent3); letter-spacing:1px; text-align:center; padding:8px; display:none; }

@media(max-width:600px){.logo-title{font-size:30px}.stats{gap:16px}.form-row{grid-template-columns:1fr}.grid{grid-template-columns:1fr 1fr}}
@media(max-width:400px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <div class="logo-title">MANGA<span>TRACK</span></div>
      <div class="logo-sub">MangaDex ¬∑ MangaFire ¬∑ Auto-detect ¬∑ v16</div>
    </div>
    <div class="header-right">
      <button class="btn btn-outline" id="themeBtn" onclick="toggleTheme()" title="Toggle light/dark">‚òÄ</button>
      <button class="btn btn-outline" onclick="openImport()">‚¨Ü IMPORT</button>
      <button class="btn btn-outline" onclick="openExport()">‚¨á EXPORT</button>
      <button class="btn btn-outline" id="checkBtn" onclick="checkAllUpdates()">
        <span class="spin-icon">‚Üª</span> CHECK UPDATES
      </button>
      <button class="btn btn-primary" onclick="openAdd()">+ ADD</button>
    </div>
  </header>

  <div class="stats">
    <div class="stat"><div class="stat-val c1" id="s-total">0</div><div class="stat-label">Tracking</div></div>
    <div class="stat"><div class="stat-val c2" id="s-new">0</div><div class="stat-label">New Chapters</div></div>
    <div class="stat"><div class="stat-val c3" id="s-reading">0</div><div class="stat-label">Reading</div></div>
    <div class="stat"><div class="stat-val c4" id="s-completed">0</div><div class="stat-label">Completed</div></div>
  </div>

  <div class="tabs">
    <button class="tab active" id="tab-lib" onclick="switchTab('library')">Library</button>
    <button class="tab" id="tab-upd" onclick="switchTab('updates')">Updates <span id="upd-badge" class="tab-badge" style="display:none"></span></button>
    <button class="tab" id="tab-sug" onclick="switchTab('suggestions')">Suggestions</button>
  </div>

  <!-- LIBRARY -->
  <div id="panel-library">
    <div class="toolbar">
      <div class="search-wrap">
        <span class="search-icon">‚åï</span>
        <input type="search" id="q" name="manga-filter-xz91" placeholder="Filter library..." oninput="renderLib()" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
      </div>
      <select class="flt" id="flt-type" onchange="renderLib()">
        <option value="">All Types</option>
        <option value="manga">Manga</option>
        <option value="manhua">Manhua</option>
        <option value="manhwa">Manhwa</option>
      </select>
      <select class="flt" id="flt-status" onchange="renderLib()">
        <option value="">All Status</option>
        <option value="reading">Reading</option>
        <option value="completed">Completed</option>
        <option value="on-hold">On Hold</option>
        <option value="dropped">Dropped</option>
        <option value="plan">Plan to Read</option>
      </select>
      <select class="flt" id="flt-sort" onchange="renderLib()">
        <option value="default">Sort: Default</option>
        <option value="title">Sort: Title A‚ÄìZ</option>
        <option value="title-desc">Sort: Title Z‚ÄìA</option>
        <option value="behind">Sort: Most Behind</option>
        <option value="latest">Sort: Latest Chapter</option>
        <option value="added">Sort: Recently Added</option>
        <option value="updated">Sort: Last Updated</option>
      </select>
    </div>
    <div class="grid" id="grid"></div>
  </div>

  <!-- UPDATES -->
  <div class="update-panel" id="panel-updates">
    <div class="log-toolbar">
      <span class="log-label">Recent Chapter Updates</span>
      <button class="btn btn-outline btn-sm" onclick="markAllRead()">Mark All Read</button>
    </div>
    <div id="log-list"></div>
  </div>

  <!-- SUGGESTIONS -->
  <div class="suggest-panel" id="panel-suggestions">
    <div class="log-toolbar">
      <span class="log-label">Based on your library</span>
      <button class="btn btn-outline btn-sm" onclick="loadSuggestions(true)">‚Üª Refresh</button>
    </div>
    <div id="suggest-grid" class="suggest-grid"></div>
  </div>
</div>

<!-- MODAL -->
<div class="overlay" id="modal">
  <div class="modal">
    <div class="modal-hd">
      <div class="modal-title" id="modal-title">ADD MANGA</div>
      <button class="close-btn" onclick="closeModal()">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="info-note">
        <strong>How it works:</strong> Search to auto-fill from MangaDex. For other sites, paste a manga page URL into <strong style="color:var(--accent2)">Custom Source URL</strong>. Natively supports <strong style="color:var(--accent3)">comix.to</strong> (via API) and <strong style="color:var(--accent3)">mangafire.to</strong> (via internal API), plus generic HTML scraping for most other sites.
      </div>

      <div class="dup-warning" id="dup-warning">‚ö† A manga with a similar title already exists in your library.</div>

      <div class="form-group" id="search-section">
        <label class="form-label">Search on MangaDex</label>
        <input class="form-input" id="md-search" placeholder="Type title to search live..." oninput="onMDSearch(event)" autocomplete="off">
        <div class="md-results" id="md-results"></div>
      </div>

      <div style="height:1px;background:var(--border)"></div>

      <div class="form-group">
        <label class="form-label">Title</label>
        <input class="form-input" id="f-title" placeholder="Title (auto-filled from search)" oninput="checkDuplicate(this.value)">
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Type</label>
          <select class="form-select" id="f-type">
            <option value="manga">Manga üáØüáµ</option>
            <option value="manhua">Manhua üá®üá≥</option>
            <option value="manhwa">Manhwa üá∞üá∑</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Reading Status</label>
          <select class="form-select" id="f-rstatus">
            <option value="reading">Reading</option>
            <option value="completed">Completed</option>
            <option value="on-hold">On Hold</option>
            <option value="dropped">Dropped</option>
            <option value="plan">Plan to Read</option>
          </select>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Chapter Read</label>
          <input class="form-input" id="f-chread" type="number" min="0" step="0.1" placeholder="0">
        </div>
        <div class="form-group">
          <label class="form-label">Latest Ch. <span style="color:var(--accent3);font-size:8px">auto-fetched</span></label>
          <div class="form-input" id="f-chlatest-display" style="color:var(--muted);font-size:11px;display:flex;align-items:center;min-height:36px">Fetching‚Ä¶</div>
          <input type="hidden" id="f-chlatest" value="0">
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">MangaDex ID <span style="color:var(--muted);font-size:8px">(auto from search)</span></label>
        <input class="form-input" id="f-mdid" placeholder="e.g. a1c7c817-4e59-43b7-9365-09675a149a6f">
      </div>
      <div class="form-group">
        <label class="form-label">Custom Source URL <span style="color:var(--accent2);font-size:8px">optional</span></label>
        <input class="form-input" id="f-customurl" placeholder="https://arenascan.com/manga/job-change-log/" oninput="previewCustomUrl(this.value)">
        <div id="custom-url-preview" style="font-size:9px;color:var(--muted);margin-top:5px;min-height:14px;letter-spacing:.5px"></div>
      </div>
    </div>
    <div class="modal-ft">
      <button class="btn btn-outline" onclick="closeModal()">Cancel</button>
      <button class="btn btn-primary" onclick="save()">SAVE</button>
    </div>
  </div>
</div>


<!-- DEBUG MODAL -->
<div class="overlay" id="debug-modal">
  <div class="modal" style="max-width:500px">
    <div class="modal-hd" style="position:sticky;top:0;background:var(--card);z-index:2">
      <div class="modal-title" id="debug-title">SOURCE DEBUG</div>
      <button class="close-btn" onclick="document.getElementById('debug-modal').classList.remove('open')">‚úï</button>
    </div>
    <div class="modal-body" id="debug-body" style="gap:8px"></div>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- IMPORT MODAL -->
<div class="overlay" id="import-modal">
  <div class="modal" style="max-width:580px">
    <div class="modal-hd">
      <div class="modal-title">IMPORT LIST</div>
      <button class="close-btn" onclick="closeImport()">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="ie-tabs">
        <button class="ie-tab active" onclick="switchIETab('paste')">üìã Paste List</button>
        <button class="ie-tab" onclick="switchIETab('file')">üìÅ Upload File</button>
        <button class="ie-tab" onclick="switchIETab('bulk')">‚ö° Bulk MangaDex</button>
      </div>

      <!-- Paste Tab -->
      <div class="ie-panel active" id="ie-paste">
        <div class="info-note">
          <strong>Format:</strong> One title per line. Optionally add chapter read after a comma.<br>
          Example: <code>Jujutsu Kaisen, 15</code> or just <code>One Piece</code>
        </div>
        <textarea class="textarea-raw" id="paste-input" placeholder="Jujutsu Kaisen Modulo, 20&#10;Witch Hat Atelier, 55&#10;Majo to Youhei&#10;One Piece, 1100"></textarea>
        <button class="btn btn-primary" style="align-self:flex-start" onclick="parsePasteInput()">PREVIEW IMPORT</button>
        <div id="paste-preview"></div>
        <div class="import-progress" id="paste-progress"></div>
      </div>

      <!-- File Tab -->
      <div class="ie-panel" id="ie-file">
        <div class="info-note">
          <strong>Supported formats:</strong> JSON (exported from this app), or CSV with columns: title, chRead, chLatest, type, readingStatus
        </div>
        <div class="drop-zone" id="drop-zone" onclick="document.getElementById('file-input').click()" ondragover="onDragOver(event)" ondragleave="onDragLeave(event)" ondrop="onDrop(event)">
          <input type="file" id="file-input" accept=".json,.csv,.txt" onchange="onFileSelect(event)">
          <div class="drop-icon">üìÇ</div>
          <div>Drop JSON or CSV file here, or click to browse</div>
          <div style="margin-top:6px;font-size:9px;opacity:.5">Supports .json ¬∑ .csv ¬∑ .txt</div>
        </div>
        <div id="file-preview"></div>
        <div class="import-progress" id="file-progress"></div>
      </div>

      <!-- Bulk MangaDex Tab -->
      <div class="ie-panel" id="ie-bulk">
        <div class="info-note">
          <strong>MangaDex IDs:</strong> Paste MangaDex manga IDs (one per line) to bulk-add with auto-fetched data.
        </div>
        <textarea class="textarea-raw" id="bulk-input" placeholder="a1c7c817-4e59-43b7-9365-09675a149a6f&#10;e78a489b-6632-4d61-b00b-5d7bcd83b7db&#10;..."></textarea>
        <button class="btn btn-primary" style="align-self:flex-start" onclick="bulkMDImport()">FETCH & IMPORT</button>
        <div class="import-progress" id="bulk-progress"></div>
      </div>
    </div>
    <div class="modal-ft" id="import-footer" style="display:none">
      <button class="btn btn-outline" onclick="closeImport()">Cancel</button>
      <button class="btn btn-primary" id="do-import-btn" onclick="doImport()">IMPORT ALL</button>
    </div>
  </div>
</div>

<!-- EXPORT MODAL -->
<div class="overlay" id="export-modal">
  <div class="modal" style="max-width:480px">
    <div class="modal-hd">
      <div class="modal-title">EXPORT LIBRARY</div>
      <button class="close-btn" onclick="closeExport()">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="info-note">
        Export your full library (<strong id="export-count">0</strong> manga) to save or transfer to another device.
      </div>
      <div class="export-opt">
        <button class="btn btn-primary" onclick="exportJSON()">‚¨á Download JSON</button>
        <button class="btn btn-outline" onclick="exportCSV()">‚¨á Download CSV</button>
        <button class="btn btn-outline" onclick="exportText()">‚¨á Plain Text List</button>
      </div>
      <div>
        <div class="form-label" style="margin-bottom:6px">Preview (JSON)</div>
        <textarea class="textarea-raw" id="export-preview" readonly style="min-height:180px;opacity:.6"></textarea>
      </div>
    </div>
    <div class="modal-ft">
      <button class="btn btn-outline" onclick="closeExport()">Close</button>
    </div>
  </div>
</div>

<script>
// ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const MD = 'https://api.mangadex.org';
const COVERS = 'https://uploads.mangadex.org/covers';
const COMICK_API = 'https://api.comick.fun';
const PROXIES = [
  'https://corsproxy.io/?',
  'https://api.allorigins.win/raw?url=',
  'https://thingproxy.freeboard.io/fetch/',
  'https://cors.eu.org/',
];

// ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let lib = JSON.parse(localStorage.getItem('mgt2_lib') || '[]');
let updLog = JSON.parse(localStorage.getItem('mgt2_log') || '[]');
let editId = null;
let mdTimer = null;
let importQueue = [];
let currentIETab = 'paste';

function saveLib() { localStorage.setItem('mgt2_lib', JSON.stringify(lib)); }
function saveLog() { localStorage.setItem('mgt2_log', JSON.stringify(updLog)); }
function uid() { return Math.random().toString(36).slice(2, 10); }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ‚îÄ‚îÄ FETCH helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function fetchWithTimeout(url, opts, ms) {
  return new Promise(resolve => {
    const timer = setTimeout(() => resolve(null), ms);
    fetch(url, opts || {}).then(res => {
      clearTimeout(timer);
      resolve(res.ok ? res : null);
    }).catch(() => { clearTimeout(timer); resolve(null); });
  });
}

// Try a JSON API url directly, then through proxies
async function fetchJSON(url, ms = 8000) {
  const attempts = [
    fetchWithTimeout(url, { headers: { 'Accept': 'application/json' } }, ms),
    ...PROXIES.map(p => fetchWithTimeout(p + encodeURIComponent(url), { headers: { 'X-Requested-With': 'XMLHttpRequest' } }, ms)),
  ];
  return new Promise(resolve => {
    let settled = 0;
    const total = attempts.length;
    attempts.forEach(p => p.then(async res => {
      if (res) {
        try { resolve(await res.json()); return; } catch {}
      }
      if (++settled === total) resolve(null);
    }));
  });
}

async function raceFetch(url, ms = 8000) {
  const attempts = [
    fetchWithTimeout(url, {}, ms),
    ...PROXIES.map(p => fetchWithTimeout(p + encodeURIComponent(url), { headers: { 'X-Requested-With': 'XMLHttpRequest' } }, ms)),
  ];
  return new Promise(resolve => {
    let settled = 0;
    const total = attempts.length;
    attempts.forEach(p => p.then(res => {
      if (res) { resolve(res); }
      else if (++settled === total) { resolve(null); }
    }));
  });
}

async function mdFetch(path) {
  const data = await fetchJSON(MD + path);
  if (data) return data;
  throw new Error('MangaDex unreachable');
}

// ‚îÄ‚îÄ COVER URL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function coverUrl(manga) {
  const rel = (manga.relationships || []).find(r => r.type === 'cover_art');
  if (!rel?.attributes?.fileName) return null;
  return `${COVERS}/${manga.id}/${rel.attributes.fileName}.256.jpg`;
}

function mdType(manga) {
  const lang = manga.attributes?.originalLanguage;
  if (lang === 'zh' || lang === 'zh-hk') return 'manhua';
  if (lang === 'ko') return 'manhwa';
  return 'manga';
}

// ‚îÄ‚îÄ comix.to ‚Äî uses the public api.comick.fun REST API ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// URL pattern: https://comix.to/title/{slug}  e.g. 8lvn-transcension-academy
async function comixChapter(url) {
  // Extract slug from URL: /title/8lvn-transcension-academy
  const slugMatch = url.match(/\/title\/([^/?#]+)/i);
  if (!slugMatch) return null;
  const slug = slugMatch[1];

  // Step 1: get comic metadata to find the hid (internal ID)
  // api.comick.fun/comic/{slug} returns {comic:{hid,last_chapter,...}}
  const meta = await fetchJSON(`${COMICK_API}/comic/${slug}`);
  if (!meta) return null;

  // last_chapter is often directly in the response
  const lastChDirect = parseFloat(meta?.comic?.last_chapter);
  if (lastChDirect > 0) return lastChDirect;

  // Step 2: fallback ‚Äî fetch chapter list sorted desc and take first
  const hid = meta?.comic?.hid;
  if (!hid) return null;
  const chapters = await fetchJSON(`${COMICK_API}/comic/${hid}/chapters?limit=1&order=desc&lang=en`);
  if (!chapters?.chapters?.length) {
    // Try without lang filter
    const allCh = await fetchJSON(`${COMICK_API}/comic/${hid}/chapters?limit=1&order=desc`);
    const ch = parseFloat(allCh?.chapters?.[0]?.chap);
    return ch > 0 ? ch : null;
  }
  const ch = parseFloat(chapters.chapters[0]?.chap);
  return ch > 0 ? ch : null;
}

// ‚îÄ‚îÄ mangafire.to ‚Äî uses internal Ajax API (no vrf token needed for chapter list)
// URL pattern: https://mangafire.to/manga/{slug}.{id}  e.g. title.82p7o
// The internal ID is the alphanumeric suffix after the dot
async function mangafireChapter(url) {
  // Extract the manga ID (e.g. "82p7o" from ".82p7o")
  const idMatch = url.match(/\.([a-z0-9]+)\s*$/i);
  if (!idMatch) return null;
  const mangaId = idMatch[1];

  // mangafire chapter list endpoint:
  // GET /ajax/manga/{mangaId}/chapter  ‚Üí JSON {status:200, result:{...}}
  // The result contains chapter objects with "number" field
  const ajaxUrl = `https://mangafire.to/ajax/manga/${mangaId}/chapter`;
  const data = await fetchJSON(ajaxUrl);
  if (data?.result) {
    // result is an object keyed by language, each containing arrays of chapter objects
    // Each chapter: {id, name, type, number, ...} or similar
    const nums = [];
    const result = data.result;
    if (Array.isArray(result)) {
      result.forEach(c => { const n = parseFloat(c.number || c.name || c.chapter); if (n > 0 && n < 99999) nums.push(n); });
    } else if (typeof result === 'object') {
      // keyed by lang
      Object.values(result).forEach(lang => {
        if (Array.isArray(lang)) lang.forEach(c => { const n = parseFloat(c.number || c.name); if (n > 0 && n < 99999) nums.push(n); });
      });
    }
    if (nums.length) return Math.max(...nums);
  }

  // Fallback: try the HTML page via proxies and extract chapter numbers from hrefs
  const res = await raceFetch(url, 10000);
  if (!res) return null;
  const html = await res.text();

  // mangafire chapter links: href="/read/slug.id/en/chapter-51"
  const hrefs = [...html.matchAll(/href="\/read\/[^"]+\/(?:en|all)\/chapter-(\d+(?:\.\d+)?)/gi)]
    .map(m => parseFloat(m[1])).filter(n => n > 0 && n < 99999);
  if (hrefs.length) return Math.max(...hrefs);

  // Generic fallback: chapter-N anywhere
  const chapNums = [...html.matchAll(/chapter[-_](\d+(?:\.\d+)?)/gi)]
    .map(m => parseFloat(m[1])).filter(n => n > 0 && n < 99999);
  return chapNums.length ? Math.max(...chapNums) : null;
}

// ‚îÄ‚îÄ SCRAPE CHAPTER FROM ANY URL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function scrapeChapterFromUrl(url) {
  // comix.to ‚Äî API-first, no scraping needed
  if (url.includes('comix.to')) {
    return await comixChapter(url);
  }

  // mangafire.to ‚Äî try internal Ajax API first, then HTML fallback
  if (url.includes('mangafire.to')) {
    return await mangafireChapter(url);
  }

  // ‚îÄ‚îÄ Generic HTML scraping for all other sites ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const res = await raceFetch(url, 9000);
  if (!res) return null;
  const html = await res.text();

  // 1. href links with /chapter-N or /ch-N (most reliable cross-site signal)
  const hrefCh = [...html.matchAll(/href="[^"]*\/(?:chapter|ch|ep)[-_](\d+(?:\.\d+)?)[/"?#]/gi)]
    .map(m => parseFloat(m[1])).filter(n => n > 0 && n < 99999);
  if (hrefCh.length) return Math.max(...hrefCh);

  // 2. data-chapter / data-num attributes
  const dataCh = [...html.matchAll(/data-(?:chapter|chap|num|number)\s*=\s*"(\d+(?:\.\d+)?)"/gi)]
    .map(m => parseFloat(m[1])).filter(n => n > 0 && n < 99999);
  if (dataCh.length) return Math.max(...dataCh);

  // 3. JSON blobs with "chapter" key
  const jsonCh = [...html.matchAll(/"(?:chapter|chap|chapterNumber|chapter_number)"\s*:\s*"?(\d+(?:\.\d+)?)"?/gi)]
    .map(m => parseFloat(m[1])).filter(n => n > 0 && n < 99999);
  if (jsonCh.length) return Math.max(...jsonCh);

  // 4. "New Chapter ... Chapter 51" ‚Äî madara theme
  const newCh = html.match(/New\s+Chapter[\s\S]{0,60}?(?:Chapter|Ch\.?)\s*([0-9]+(?:\.[0-9]+)?)/i);
  if (newCh) { const n = parseFloat(newCh[1]); if (n > 0 && n < 99999) return n; }

  // 5. Slug-based: /manga/slug-chapter-51/ style
  const slugMatch = url.match(/\/(?:manga|comic|series|webtoon|manhwa|manhua)\/([^/]+)\/?$/i);
  if (slugMatch) {
    const slug = slugMatch[1].replace(/\.[a-z0-9]{3,8}$/, '');
    const escaped = slug.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/-/g, '[-_]');
    const re = new RegExp(escaped + '[-_](?:chapter[-_])?([0-9]+(?:\\.[0-9]+)?)', 'gi');
    const nums = [...html.matchAll(re)].map(m => parseFloat(m[1])).filter(n => n > 0 && n < 99999);
    if (nums.length) return Math.max(...nums);
  }

  // 6. Generic "Chapter N" ‚Äî last resort
  const all = [...html.matchAll(/(?:chapter|ch\.?)\s*([0-9]+(?:\.[0-9]+)?)/gi)]
    .map(m => parseFloat(m[1])).filter(n => n > 0 && n < 9999);
  if (all.length) return Math.max(...all);

  return null;
}

// ‚îÄ‚îÄ PREVIEW CUSTOM URL (fires when user types in the field) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let urlPreviewTimer = null;
async function previewCustomUrl(val) {
  const el = document.getElementById('custom-url-preview');
  if (!el) return;
  clearTimeout(urlPreviewTimer);
  if (!val || !val.startsWith('http')) { el.textContent = ''; return; }
  el.style.color = 'var(--muted)';
  el.textContent = 'Detecting‚Ä¶';
  urlPreviewTimer = setTimeout(async () => {
    const n = await scrapeChapterFromUrl(val);
    if (n) {
      el.style.color = 'var(--accent3)';
      el.textContent = '‚úì Detected Ch.' + n + ' from this URL';
    } else {
      el.style.color = 'var(--accent)';
      el.textContent = '‚úó Could not detect chapter ‚Äî try a different page';
    }
  }, 800);
}

// ‚îÄ‚îÄ GET LATEST CHAPTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function getLatestCh(mdId, customUrl) {
  const all = await Promise.allSettled([

    // Priority 1: Custom URL ‚Äî user knows where the chapters live
    (async () => {
      if (!customUrl) return null;
      const n = await scrapeChapterFromUrl(customUrl);
      return (n > 0) ? { ch: n, source: 'Custom URL', t: 2 } : null;
    })(),

    // Priority 2a: MangaDex feed ‚Äî all languages, take highest
    (async () => {
      if (!mdId) return null;
      const d = await mdFetch('/manga/' + mdId + '/feed?limit=500&offset=0&order[chapter]=desc&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic');
      const nums = (d?.data || []).map(c => parseFloat(c.attributes?.chapter)).filter(n => !isNaN(n) && n > 0);
      if (!nums.length) return null;
      if ((d?.total || 0) > 500) {
        try {
          const d2 = await mdFetch('/manga/' + mdId + '/feed?limit=500&offset=500&order[chapter]=desc&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic');
          (d2?.data || []).forEach(c => { const n = parseFloat(c.attributes?.chapter); if (!isNaN(n) && n > 0) nums.push(n); });
        } catch {}
      }
      return { ch: Math.max(...nums), source: 'MangaDex', t: 1 };
    })(),

    // Priority 2b: MangaDex aggregate ‚Äî cross-check
    (async () => {
      if (!mdId) return null;
      const d = await mdFetch('/manga/' + mdId + '/aggregate');
      const nums = [];
      for (const vol of Object.values(d.volumes || {}))
        for (const ch of Object.values(vol.chapters || {})) { const n = parseFloat(ch.chapter); if (!isNaN(n) && n > 0) nums.push(n); }
      return nums.length ? { ch: Math.max(...nums), source: 'MangaDex', t: 1 } : null;
    })(),

  ]);

  const results = all.filter(r => r.status === 'fulfilled' && r.value?.ch > 0).map(r => r.value);
  if (!results.length) return null;
  // Highest tier wins; within same tier, highest chapter wins
  return results.reduce((a, b) => b.t > a.t ? b : a.t > b.t ? a : b.ch > a.ch ? b : a);
}

// ‚îÄ‚îÄ DEBUG SOURCES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function debugSources(id) {
  const m = lib.find(x => x.id === id);
  if (!m) return;
  const modal = document.getElementById('debug-modal');
  const body = document.getElementById('debug-body');
  const title = m.title.length > 22 ? m.title.slice(0, 22) + '‚Ä¶' : m.title;
  document.getElementById('debug-title').textContent = title;
  modal.classList.add('open');

  const rows = [
    { key: 'custom',  label: 'Custom URL', sub: m.customUrl ? m.customUrl.replace(/https?:\/\//,'').slice(0,28) + (m.customUrl.length > 28 ? '‚Ä¶' : '') : 'not set', skip: !m.customUrl },
    { key: 'md-feed', label: 'MangaDex Feed',      skip: !m.mdId },
    { key: 'md-agg',  label: 'MangaDex Aggregate', skip: !m.mdId },
  ];

  body.innerHTML = `
    <div style="font-size:9px;color:var(--muted);letter-spacing:.5px;line-height:2;padding:2px 0 6px">
      ${m.mdId ? 'ID: <span style="opacity:.5">' + m.mdId + '</span><br>' : ''}
      Stored: <strong style="color:var(--text)">Ch.${m.chLatest || '?'}</strong> &middot; via <span style="color:var(--accent3)">${m.chSource || 'none'}</span>
    </div>
    ${rows.map(r => `
    <div id="dbg-${r.key}" style="display:flex;justify-content:space-between;align-items:center;padding:9px 12px;background:var(--surface);border:1px solid var(--border);border-left:3px solid ${r.skip ? '#333' : 'var(--muted)'};opacity:${r.skip ? '.35' : '1'}">
      <div>
        <div style="font-size:9px;color:var(--muted);letter-spacing:1px;text-transform:uppercase">${r.label}</div>
        ${r.sub ? '<div style="font-size:8px;color:var(--muted);opacity:.6;margin-top:2px">' + esc(r.sub) + '</div>' : ''}
      </div>
      <span id="dbg-val-${r.key}" style="font-size:9px;color:var(--muted)">${r.skip ? 'skipped' : '‚Ä¶'}</span>
    </div>`).join('')}
    <div id="dbg-best" style="display:none;padding:10px 12px;background:var(--card);border:1px solid var(--accent3);text-align:center;margin-top:4px"></div>`;

  let best = 0;
  function update(key, ch) {
    const row = document.getElementById('dbg-' + key);
    const val = document.getElementById('dbg-val-' + key);
    if (!row || !val) return;
    if (ch > 0) {
      row.style.borderLeftColor = 'var(--accent3)';
      val.style.cssText = 'font-size:15px;font-weight:700;color:var(--accent3)';
      val.textContent = 'Ch.' + ch;
      if (ch > best) {
        best = ch;
        const el = document.getElementById('dbg-best');
        el.style.display = 'block';
        el.innerHTML = '<span style="color:var(--muted);font-size:9px;letter-spacing:2px">BEST </span><strong style="color:var(--accent3);font-size:22px"> Ch.' + best + '</strong>';
      }
    } else {
      row.style.borderLeftColor = 'var(--accent)';
      val.style.cssText = 'font-size:13px;color:var(--accent)';
      val.textContent = '‚Äî';
    }
  }

  if (m.customUrl) {
    raceFetch(m.customUrl).then(async res => {
      if (!res) { update('custom', 0); return; }
      const html = await res.text();
      const n = await scrapeChapterFromUrl(m.customUrl).catch(() => null);
      update('custom', n || 0);
    }).catch(() => update('custom', 0));
  }

  if (m.mdId) {
    raceFetch(MD + '/manga/' + m.mdId + '/feed?limit=500&order[chapter]=desc&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic').then(async res => {
      try {
        const d = await res.json();
        const nums = (d?.data || []).map(c => parseFloat(c.attributes?.chapter)).filter(n => !isNaN(n) && n > 0);
        update('md-feed', nums.length ? Math.max(...nums) : 0);
      } catch { update('md-feed', 0); }
    }).catch(() => update('md-feed', 0));

    raceFetch(MD + '/manga/' + m.mdId + '/aggregate').then(async res => {
      try {
        const d = await res.json();
        const nums = [];
        for (const vol of Object.values(d.volumes || {}))
          for (const ch of Object.values(vol.chapters || {})) { const n = parseFloat(ch.chapter); if (!isNaN(n) && n > 0) nums.push(n); }
        update('md-agg', nums.length ? Math.max(...nums) : 0);
      } catch { update('md-agg', 0); }
    }).catch(() => update('md-agg', 0));
  }
}

// ‚îÄ‚îÄ REFRESH SINGLE MANGA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function refreshOne(id) {
  const m = lib.find(x => x.id === id);
  if (!m) return;
  showToast('Refreshing ' + m.title + '‚Ä¶');
  try {
    const r = await getLatestCh(m.mdId, m.customUrl || '');
    if (r && r.ch > 0) {
      const old = m.chLatest || 0;
      m.chSource = r.source;
      m.chLatest = r.ch;
      m.hasNew = m.chLatest > (m.chRead || 0);
      if (r.ch > old && old > 0) {
        updLog.unshift({ id: uid(), mangaId: m.id, title: m.title, type: m.type, oldCh: old, newCh: r.ch, source: r.source, cover: m.cover || '', time: Date.now(), read: false });
        saveLog();
      }
      saveLib(); renderLib();
      showToast(m.title + ' ‚Üí Ch.' + r.ch + ' ‚úì');
    } else {
      showToast('Could not fetch chapters', 'err');
    }
  } catch(e) { showToast('Error: ' + e.message, 'err'); }
}

// ‚îÄ‚îÄ CHECK ALL UPDATES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function checkAllUpdates() {
  const tracked = lib.filter(m => m.mdId || m.customUrl);
  if (!tracked.length) {
    showToast('Add manga with a MangaDex ID or Custom URL first!', 'err');
    return;
  }
  const btn = document.getElementById('checkBtn');
  btn.classList.add('spinning');
  btn.disabled = true;
  let found = 0, done = 0;
  showToast('Checking ' + tracked.length + ' manga‚Ä¶');

  await Promise.allSettled(tracked.map(async m => {
    try {
      const r = await getLatestCh(m.mdId, m.customUrl || '');
      if (r && r.ch > 0) {
        m.chSource = r.source;
        const prev = m.chLatest || 0;
        m.chLatest = Math.max(prev, r.ch);
        m.hasNew = m.chLatest > (m.chRead || 0);
        if (r.ch > prev) {
          found++;
          updLog.unshift({ id: uid(), mangaId: m.id, title: m.title, type: m.type, oldCh: prev, newCh: r.ch, source: r.source, cover: m.cover || '', time: Date.now(), read: false });
        }
        saveLib(); renderLib();
      }
    } catch {}
    done++;
    showToast('Checked ' + done + '/' + tracked.length + '‚Ä¶');
  }));

  updLog = updLog.slice(0, 100);
  saveLib(); saveLog(); renderLib(); renderLog();
  btn.classList.remove('spinning');
  btn.disabled = false;
  if (found > 0) showToast('üéâ ' + found + ' new update' + (found > 1 ? 's' : '') + '!');
  else showToast('All up to date ‚úì');
}

// ‚îÄ‚îÄ MANGADEX SEARCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function searchMD(title) {
  const d = await mdFetch('/manga?title=' + encodeURIComponent(title) + '&limit=8&includes[]=cover_art&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic');
  return d.data || [];
}

// ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderLib() {
  const grid = document.getElementById('grid');
  const q = document.getElementById('q').value.toLowerCase();
  const ft = document.getElementById('flt-type').value;
  const fs = document.getElementById('flt-status').value;
  const sortBy = document.getElementById('flt-sort').value;

  let items = lib.filter(m => {
    if (q && !m.title.toLowerCase().includes(q)) return false;
    if (ft && m.type !== ft) return false;
    if (fs && m.readingStatus !== fs) return false;
    return true;
  });

  // Sorting
  items.sort((a, b) => {
    switch (sortBy) {
      case 'title':       return a.title.localeCompare(b.title);
      case 'title-desc':  return b.title.localeCompare(a.title);
      case 'behind':      return ((b.chLatest||0)-(b.chRead||0)) - ((a.chLatest||0)-(a.chRead||0));
      case 'latest':      return (b.chLatest||0) - (a.chLatest||0);
      case 'added':       return (b.addedAt||0) - (a.addedAt||0);
      case 'updated':     return (b.lastUpdated||b.addedAt||0) - (a.lastUpdated||a.addedAt||0);
      default:            return (b.hasNew - a.hasNew) || ((b.addedAt||0) - (a.addedAt||0));
    }
  });

  if (!items.length) {
    grid.innerHTML = '<div class="empty"><div class="empty-icon">üìö</div><div class="empty-title">' + (lib.length ? 'No Results' : 'Empty Library') + '</div><div class="empty-sub">' + (lib.length ? 'Try different filters' : 'Click + ADD and search for manga') + '</div></div>';
    return updateStats();
  }

  grid.innerHTML = items.map(m => {
    const hasNew = m.hasNew && (m.chLatest > 0) && (m.chLatest > (m.chRead || 0));
    const behind = Math.max(0, (m.chLatest || 0) - (m.chRead || 0));
    const ss = m.seriesStatus || 'ongoing';
    const rlabel = { reading:'Reading', completed:'Completed', 'on-hold':'On Hold', dropped:'Dropped', plan:'Plan to Read' }[m.readingStatus] || m.readingStatus;
    const slabel = { ongoing:'Ongoing', completed:'Completed', hiatus:'Hiatus', cancelled:'Cancelled' }[ss] || ss;
    const srcBadge = m.customUrl ? '<span style="color:var(--accent2);font-size:8px">‚ö° ' + esc(m.chSource || 'Custom') + '</span>' : m.chSource ? '<span style="color:var(--accent3);opacity:.7;font-size:8px">' + esc(m.chSource) + '</span>' : m.mdId ? '<span style="opacity:.3;font-size:8px">MangaDex</span>' : '<span style="color:var(--accent);opacity:.6;font-size:8px">‚ö† no source</span>';
    const behindBadge = behind > 1 ? '<span class="behind-badge">-' + behind + ' ch</span>' : '';
    return '<div class="card' + (hasNew ? ' has-new' : '') + '" id="card-' + m.id + '">' +
      (hasNew ? '<div class="new-pill">New Ch.</div>' : '') +
      (m.cover ? '<img class="card-cover" src="' + esc(m.cover) + '" loading="lazy" onerror="this.style.display=\'none\';this.nextElementSibling.style.display=\'flex\'" alt="">' : '') +
      '<div class="cover-ph"' + (m.cover ? ' style="display:none"' : '') + '>' + m.title.charAt(0).toUpperCase() + '</div>' +
      '<div class="card-body">' +
        '<div class="card-type type-' + m.type + '">' + m.type.toUpperCase() + '</div>' +
        '<div class="card-title">' + esc(m.title) + '</div>' +
        '<div class="card-meta">' +
          '<div>' +
            '<div class="ch-read">Read: Ch.' + (m.chRead || 0) + behindBadge + '</div>' +
            '<div class="ch-latest' + (hasNew ? ' new' : '') + '">Latest: ' + (m.chLatest > 0 ? 'Ch.' + m.chLatest : '?') + (hasNew ? ' ‚Üë' : '') + '</div>' +
          '</div>' +
          '<div class="card-actions">' +
            '<button class="plus-one" title="+1 chapter read" onclick="plusOne(\'' + m.id + '\')">+1</button>' +
            '<button class="icon-btn" title="Mark all as read" onclick="markRead(\'' + m.id + '\')">‚úì</button>' +
            '<button class="icon-btn" title="Refresh" onclick="refreshOne(\'' + m.id + '\')">‚Üª</button>' +
            '<button class="icon-btn" title="Debug sources" onclick="debugSources(\'' + m.id + '\')">‚öë</button>' +
            '<button class="icon-btn" title="Edit" onclick="openEdit(\'' + m.id + '\')">‚úé</button>' +
            '<button class="icon-btn del" title="Remove" onclick="del(\'' + m.id + '\')">‚úï</button>' +
          '</div>' +
        '</div>' +
        '<div class="card-foot"><span class="dot ' + ss + '"></span>' + slabel + ' ¬∑ ' + rlabel + '</div>' +
        '<div class="card-source">' + srcBadge + '</div>' +
      '</div>' +
    '</div>';
  }).join('');
  updateStats();
}

function updateStats() {
  document.getElementById('s-total').textContent = lib.length;
  document.getElementById('s-new').textContent = lib.filter(m => m.hasNew && (m.chLatest||0) > (m.chRead||0)).length;
  document.getElementById('s-reading').textContent = lib.filter(m => m.readingStatus === 'reading').length;
  document.getElementById('s-completed').textContent = lib.filter(m => m.readingStatus === 'completed').length;
  const unread = updLog.filter(u => !u.read).length;
  const badge = document.getElementById('upd-badge');
  badge.style.display = unread ? 'inline' : 'none';
  badge.textContent = unread;
}

function renderLog() {
  const list = document.getElementById('log-list');
  if (!updLog.length) {
    list.innerHTML = '<div class="empty" style="padding:60px 0"><div class="empty-icon">üîî</div><div class="empty-title">No Updates Yet</div><div class="empty-sub">Click Check Updates to fetch real data</div></div>';
    return;
  }
  list.innerHTML = [...updLog].sort((a,b)=>b.time-a.time).map(u =>
    '<div class="log-entry' + (u.read ? '' : ' unread') + '">' +
    (u.cover ? '<img class="log-cover" src="' + esc(u.cover) + '" loading="lazy" onerror="this.style.display=\'none\';this.nextElementSibling.style.display=\'flex\'" alt=""><div class="log-cover-ph" style="display:none">' + u.title.charAt(0) + '</div>' : '<div class="log-cover-ph">' + u.title.charAt(0) + '</div>') +
    '<div class="log-info"><div class="log-title-txt">' + esc(u.title) + '</div>' +
    '<div class="log-ch">Ch.' + u.oldCh + ' ‚Üí Ch.' + u.newCh + ' <span style="color:var(--muted);font-size:9px">(+' + (u.newCh - u.oldCh).toFixed(1).replace(/\.0$/, '') + ')</span>' +
    (u.source ? ' <span style="color:var(--accent3);font-size:9px">¬∑ ' + esc(u.source) + '</span>' : '') + '</div></div>' +
    '<div class="log-time">' + timeAgo(u.time) + '</div></div>'
  ).join('');
}

function timeAgo(ts) {
  const d = Date.now() - ts, m = Math.floor(d/60000);
  if (m < 1) return 'just now';
  if (m < 60) return m + 'm ago';
  const h = Math.floor(m/60);
  if (h < 24) return h + 'h ago';
  return Math.floor(h/24) + 'd ago';
}

// ‚îÄ‚îÄ ACTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function markRead(id) {
  const m = lib.find(x => x.id === id);
  if (!m) return;
  if (m.chLatest > 0 && m.chLatest > (m.chRead || 0)) {
    m.chRead = m.chLatest; m.hasNew = false;
    saveLib(); renderLib();
    showToast('Marked Ch.' + m.chLatest + ' as read ‚úì');
  } else if (!m.chLatest) {
    showToast('Hit Refresh or Check Updates first', 'err');
  } else {
    showToast('Already up to date!');
  }
}

function del(id) {
  if (!confirm('Remove from library?')) return;
  lib = lib.filter(m => m.id !== id);
  saveLib(); renderLib();
  showToast('Removed.');
}

function markAllRead() {
  updLog.forEach(u => u.read = true);
  lib.forEach(m => { if (m.hasNew) { m.chRead = m.chLatest; m.hasNew = false; } });
  saveLib(); saveLog(); renderLib(); renderLog();
  showToast('All marked as read ‚úì');
}

// ‚îÄ‚îÄ TABS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function switchTab(name) {
  ['lib','upd','sug'].forEach(t => { const el = document.getElementById('tab-'+t); if(el) el.classList.remove('active'); });
  const tabMap = { library:'lib', updates:'upd', suggestions:'sug' };
  const el = document.getElementById('tab-' + tabMap[name]);
  if (el) el.classList.add('active');
  document.getElementById('panel-library').style.display = name === 'library' ? 'block' : 'none';
  document.getElementById('panel-updates').classList.toggle('active', name === 'updates');
  document.getElementById('panel-suggestions').classList.toggle('active', name === 'suggestions');
  if (name === 'updates') renderLog();
  if (name === 'suggestions') loadSuggestions();
}

// ‚îÄ‚îÄ +1 CHAPTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function plusOne(id) {
  const m = lib.find(x => x.id === id);
  if (!m) return;
  m.chRead = Math.round(((m.chRead || 0) + 1) * 10) / 10;
  m.hasNew = (m.chLatest || 0) > m.chRead;
  m.lastUpdated = Date.now();
  saveLib(); renderLib();
  showToast(m.title + ' ‚Üí Ch.' + m.chRead + ' ‚úì');
}

// ‚îÄ‚îÄ THEME TOGGLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function toggleTheme() {
  const isLight = document.body.classList.toggle('light');
  localStorage.setItem('mgt_theme', isLight ? 'light' : 'dark');
  document.getElementById('themeBtn').textContent = isLight ? 'üåô' : '‚òÄ';
}
(function initTheme() {
  if (localStorage.getItem('mgt_theme') === 'light') {
    document.body.classList.add('light');
    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('themeBtn');
      if (btn) btn.textContent = 'üåô';
    });
  }
})();

// ‚îÄ‚îÄ DUPLICATE DETECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function checkDuplicate(title) {
  if (!title || title.length < 3) { hideDupWarning(); return; }
  const norm = t => t.toLowerCase().replace(/[^a-z0-9]/g, '');
  const input = norm(title);
  const dup = lib.find(m => {
    const existing = norm(m.title);
    if (existing === input) return true;
    // fuzzy: one contains the other with at least 80% overlap
    const shorter = Math.min(existing.length, input.length);
    const longer = Math.max(existing.length, input.length);
    if (shorter < 4) return existing === input;
    if (longer > 0 && shorter / longer > 0.85) {
      return existing.includes(input) || input.includes(existing);
    }
    return false;
  });
  const warn = document.getElementById('dup-warning');
  if (dup && warn) {
    warn.style.display = 'block';
    warn.textContent = '‚ö† "' + dup.title + '" is already in your library.';
  } else {
    hideDupWarning();
  }
}
function hideDupWarning() {
  const w = document.getElementById('dup-warning');
  if (w) w.style.display = 'none';
}

// ‚îÄ‚îÄ SUGGESTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let suggestionsLoaded = false;
async function loadSuggestions(force = false) {
  if (suggestionsLoaded && !force) return;
  const grid = document.getElementById('suggest-grid');
  if (!grid) return;

  const mdManga = lib.filter(m => m.mdId);
  if (!mdManga.length) {
    grid.innerHTML = '<div class="suggest-loading" style="animation:none">Add manga with MangaDex IDs to get suggestions.</div>';
    return;
  }

  grid.innerHTML = '<div class="suggest-loading">Finding recommendations‚Ä¶</div>';
  suggestionsLoaded = true;

  try {
    // Pick up to 5 random reading manga with mdId as seeds
    const seeds = mdManga.filter(m => m.readingStatus === 'reading' || m.readingStatus === 'completed')
      .sort(() => Math.random() - .5).slice(0, 5);
    if (!seeds.length) seeds.push(...mdManga.slice(0, 5));

    // Fetch tags from seeds, collect popular ones
    const tagCounts = {};
    await Promise.allSettled(seeds.map(async m => {
      try {
        const d = await mdFetch('/manga/' + m.mdId + '?includes[]=tag');
        (d?.data?.attributes?.tags || []).forEach(t => {
          const name = t.attributes?.name?.en;
          if (name) tagCounts[t.id] = (tagCounts[t.id] || { name, count: 0, id: t.id });
          if (name) tagCounts[t.id].count++;
        });
      } catch {}
    }));

    // Take top 3 tags as seeds for recommendations
    const topTags = Object.values(tagCounts).sort((a,b) => b.count - a.count).slice(0, 3).map(t => t.id);
    const existingIds = new Set(lib.map(m => m.mdId).filter(Boolean));

    let results = [];
    if (topTags.length) {
      const tagQuery = topTags.map(id => 'includedTags[]=' + id).join('&');
      const d = await mdFetch('/manga?' + tagQuery + '&limit=18&includes[]=cover_art&contentRating[]=safe&contentRating[]=suggestive&order[rating]=desc');
      results = (d?.data || []).filter(m => !existingIds.has(m.id));
    }

    // Fallback: popular manga
    if (results.length < 6) {
      const d = await mdFetch('/manga?limit=18&includes[]=cover_art&contentRating[]=safe&contentRating[]=suggestive&order[rating]=desc');
      const more = (d?.data || []).filter(m => !existingIds.has(m.id) && !results.find(r => r.id === m.id));
      results = [...results, ...more];
    }

    results = results.slice(0, 12);

    if (!results.length) {
      grid.innerHTML = '<div class="suggest-loading" style="animation:none">No suggestions found ‚Äî try adding more manga first!</div>';
      return;
    }

    grid.innerHTML = results.map(m => {
      const title = m.attributes?.title?.en || Object.values(m.attributes?.title || {})[0] || 'Unknown';
      const status = m.attributes?.status || 'ongoing';
      const type = mdType(m);
      const cover = coverUrl(m);
      const id = m.id;
      const info = JSON.stringify({ id, title, type, status, cover: cover || '' }).replace(/'/g, "&#39;");
      return '<div class="suggest-card">' +
        (cover ? '<img class="suggest-cover" src="' + esc(cover) + '" loading="lazy" onerror="this.style.display=\'none\';this.nextElementSibling.style.display=\'flex\'" alt=""><div class="suggest-ph" style="display:none">' + title.charAt(0) + '</div>'
                : '<div class="suggest-ph">' + title.charAt(0) + '</div>') +
        '<div class="suggest-body">' +
          '<div class="suggest-title">' + esc(title) + '</div>' +
          '<div class="suggest-meta">' + type.toUpperCase() + ' ¬∑ ' + status + '</div>' +
          '<button class="suggest-add" onclick=\'quickAddSuggestion(' + info + ')\'>+ Add to Library</button>' +
        '</div></div>';
    }).join('');

  } catch(e) {
    grid.innerHTML = '<div class="suggest-loading" style="animation:none">Could not load suggestions. Check your connection.</div>';
  }
}

async function quickAddSuggestion(info) {
  if (lib.find(m => m.mdId === info.id)) { showToast('Already in library!', 'err'); return; }
  showToast('Adding ' + info.title + '‚Ä¶');
  try {
    let cover = info.cover || '';
    let seriesStatus = info.status || 'ongoing';
    if (!cover) {
      const d = await mdFetch('/manga/' + info.id + '?includes[]=cover_art');
      cover = coverUrl(d.data) || '';
      seriesStatus = d.data?.attributes?.status || 'ongoing';
    }
    const r = await getLatestCh(info.id, '');
    lib.push({ id: uid(), title: info.title, mdId: info.id, customUrl: '', cover, seriesStatus, type: info.type || 'manga', readingStatus: 'plan', chRead: 0, chLatest: r?.ch || 0, chSource: r?.source || '', hasNew: false, addedAt: Date.now() });
    saveLib(); renderLib();
    showToast('"' + info.title + '" added! ‚úì');
    // Refresh suggestions to remove added title
    suggestionsLoaded = false;
    loadSuggestions();
  } catch(e) { showToast('Error adding: ' + e.message, 'err'); }
}

// ‚îÄ‚îÄ MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openAdd() {
  editId = null;
  document.getElementById('modal-title').textContent = 'ADD MANGA';
  document.getElementById('search-section').style.display = '';
  clearForm();
  document.getElementById('modal').classList.add('open');
}

function openEdit(id) {
  const m = lib.find(x => x.id === id);
  if (!m) return;
  editId = id;
  document.getElementById('modal-title').textContent = 'EDIT MANGA';
  document.getElementById('search-section').style.display = 'none';
  document.getElementById('f-title').value = m.title;
  document.getElementById('f-type').value = m.type;
  document.getElementById('f-rstatus').value = m.readingStatus;
  document.getElementById('f-chread').value = m.chRead || '';
  document.getElementById('f-chlatest').value = m.chLatest || 0;
  document.getElementById('f-mdid').value = m.mdId || '';
  document.getElementById('f-customurl').value = m.customUrl || '';
  const disp = document.getElementById('f-chlatest-display');
  if (disp) {
    disp.textContent = m.chLatest > 0 ? 'Ch.' + m.chLatest + (m.chSource ? '  (' + m.chSource + ')' : '') : 'Not fetched yet';
    disp.style.color = m.chLatest > 0 ? 'var(--accent3)' : 'var(--muted)';
  }
  document.getElementById('modal').classList.add('open');
}

function closeModal() {
  document.getElementById('modal').classList.remove('open');
  document.getElementById('md-results').classList.remove('open');
  clearTimeout(mdTimer);
}

function clearForm() {
  ['f-title','f-chread','f-mdid','f-customurl','md-search'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  document.getElementById('f-chlatest').value = '0';
  const disp = document.getElementById('f-chlatest-display');
  if (disp) { disp.textContent = 'Select a title above to auto-fetch'; disp.style.color = 'var(--muted)'; }
  document.getElementById('f-type').value = 'manga';
  document.getElementById('f-rstatus').value = 'reading';
  const r = document.getElementById('md-results');
  r.classList.remove('open'); r.innerHTML = '';
  hideDupWarning();
  const prev = document.getElementById('custom-url-preview');
  if (prev) prev.textContent = '';
}

async function save() {
  const title = document.getElementById('f-title').value.trim();
  if (!title) { showToast('Title is required!', 'err'); return; }
  const mdId = document.getElementById('f-mdid').value.trim();
  const customUrl = document.getElementById('f-customurl').value.trim();
  const chRead = parseFloat(document.getElementById('f-chread').value) || 0;
  const chLatest = parseFloat(document.getElementById('f-chlatest').value) || 0;

  if (editId) {
    const m = lib.find(x => x.id === editId);
    m.title = title; m.mdId = mdId; m.customUrl = customUrl;
    m.type = document.getElementById('f-type').value;
    m.readingStatus = document.getElementById('f-rstatus').value;
    m.chRead = chRead;
    if (chLatest > 0) m.chLatest = Math.max(chLatest, m.chLatest || 0);
    m.hasNew = (m.chLatest || 0) > m.chRead;
    showToast('Saved ‚úì');
  } else {
    let cover = '', seriesStatus = 'ongoing';
    if (mdId) {
      try {
        const d = await mdFetch('/manga/' + mdId + '?includes[]=cover_art');
        cover = coverUrl(d.data) || '';
        seriesStatus = d.data?.attributes?.status || 'ongoing';
      } catch {}
    }
    lib.push({ id: uid(), title, mdId, customUrl, cover, seriesStatus, type: document.getElementById('f-type').value, readingStatus: document.getElementById('f-rstatus').value, chRead, chLatest, hasNew: chLatest > chRead && chLatest > 0, addedAt: Date.now() });
    showToast('"' + title + '" added! ‚úì');
  }
  saveLib(); closeModal(); renderLib();
}

// ‚îÄ‚îÄ MANGADEX LIVE SEARCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function onMDSearch(e) {
  clearTimeout(mdTimer);
  const val = e.target.value.trim();
  const results = document.getElementById('md-results');
  if (!val) { results.classList.remove('open'); return; }
  results.innerHTML = '<div class="sr-msg loading">SEARCHING MANGADEX‚Ä¶</div>';
  results.classList.add('open');
  mdTimer = setTimeout(async () => {
    try {
      const data = await searchMD(val);
      if (!data.length) { results.innerHTML = '<div class="sr-msg">No results found</div>'; return; }
      results.innerHTML = data.map(m => {
        const title = m.attributes.title.en || Object.values(m.attributes.title)[0] || 'Unknown';
        const type = mdType(m);
        const status = m.attributes.status || 'ongoing';
        const cover = coverUrl(m);
        const info = JSON.stringify({ id: m.id, title, type, status, cover: cover||'' });
        return '<div class="sr-item" onclick=\'selectMD(' + info.replace(/'/g,"&#39;") + ')\'>' +
          (cover ? '<img class="sr-thumb" src="' + esc(cover) + '" loading="lazy" onerror="this.style.display=\'none\';this.nextElementSibling.style.display=\'flex\'" alt=""><div class="sr-ph" style="display:none">' + title.charAt(0) + '</div>' : '<div class="sr-ph">' + title.charAt(0) + '</div>') +
          '<div class="sr-info"><div class="sr-name">' + esc(title) + '</div><div class="sr-meta">' + type + ' ¬∑ ' + status + '</div></div></div>';
      }).join('');
    } catch(err) { results.innerHTML = '<div class="sr-msg">Error: ' + esc(err.message) + '</div>'; }
  }, 600);
}

async function selectMD(info) {
  document.getElementById('f-title').value = info.title;
  checkDuplicate(info.title);
  document.getElementById('f-type').value = info.type;
  document.getElementById('f-mdid').value = info.id;
  document.getElementById('f-chlatest').value = '0';
  const disp = document.getElementById('f-chlatest-display');
  disp.textContent = 'Fetching‚Ä¶'; disp.style.color = 'var(--muted)';
  document.getElementById('md-results').classList.remove('open');
  document.getElementById('md-search').value = '';
  showToast('Fetching latest chapter‚Ä¶');
  try {
    const r = await getLatestCh(info.id, '');
    if (r?.ch > 0) {
      document.getElementById('f-chlatest').value = r.ch;
      disp.textContent = 'Ch.' + r.ch + '  (' + r.source + ')';
      disp.style.color = 'var(--accent3)';
      showToast('Latest: Ch.' + r.ch + ' ‚úì');
    } else {
      disp.textContent = 'Not found ‚Äî will fetch on Check Updates';
      showToast('Could not fetch chapter', 'err');
    }
  } catch { disp.textContent = 'Error ‚Äî will retry on Check Updates'; }
}

// ‚îÄ‚îÄ IMPORT / EXPORT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openImport() {
  importQueue = [];
  document.getElementById('import-modal').classList.add('open');
  document.getElementById('import-footer').style.display = 'none';
  document.getElementById('paste-input').value = '';
  document.getElementById('bulk-input').value = '';
  document.getElementById('paste-preview').innerHTML = '';
  document.getElementById('file-preview').innerHTML = '';
  switchIETab('paste');
}
function closeImport() { document.getElementById('import-modal').classList.remove('open'); }
function openExport() {
  document.getElementById('export-count').textContent = lib.length;
  const preview = lib.map(m => ({ title: m.title, type: m.type, readingStatus: m.readingStatus, chRead: m.chRead, chLatest: m.chLatest, mdId: m.mdId || '', customUrl: m.customUrl || '', seriesStatus: m.seriesStatus || 'ongoing', cover: m.cover || '' }));
  document.getElementById('export-preview').value = JSON.stringify(preview, null, 2);
  document.getElementById('export-modal').classList.add('open');
}
function closeExport() { document.getElementById('export-modal').classList.remove('open'); }

function switchIETab(name) {
  currentIETab = name;
  document.querySelectorAll('.ie-tab').forEach((t,i) => t.classList.toggle('active', ['paste','file','bulk'][i] === name));
  document.querySelectorAll('.ie-panel').forEach(p => p.classList.remove('active'));
  document.getElementById('ie-' + name).classList.add('active');
}

function renderImportPreview(containerId) {
  const c = document.getElementById(containerId);
  if (!importQueue.length) { c.innerHTML = ''; return; }
  c.innerHTML = '<div class="import-preview">' + importQueue.map(item =>
    '<div class="preview-row"><div class="preview-status ' + (item.status === 'ok' ? 'ps-ok' : item.status === 'dup' ? 'ps-dup' : 'ps-err') + '"></div><div class="preview-title">' + esc(item.title) + '</div><div class="preview-meta">Ch.' + (item.chRead || 0) + (item.status === 'dup' ? ' ¬∑ DUP' : '') + '</div></div>'
  ).join('') + '</div>';
  document.getElementById('import-footer').style.display = 'flex';
  document.getElementById('do-import-btn').disabled = false;
}

function parsePasteInput() {
  const raw = document.getElementById('paste-input').value.trim();
  if (!raw) { showToast('Nothing to import!', 'err'); return; }
  importQueue = raw.split('\n').map(line => {
    const parts = line.split(',');
    const title = parts[0].trim();
    if (!title) return null;
    const chRead = parseFloat(parts[1]) || 0;
    const existing = lib.find(m => m.title.toLowerCase() === title.toLowerCase());
    return { title, chRead, type: 'manga', readingStatus: 'reading', status: existing ? 'dup' : 'ok' };
  }).filter(Boolean);
  renderImportPreview('paste-preview');
}

async function doImport() {
  const btn = document.getElementById('do-import-btn');
  btn.disabled = true;
  const items = importQueue.filter(i => i.status !== 'dup');
  if (!items.length) { showToast('Nothing new to import (all duplicates)', 'err'); btn.disabled = false; return; }

  const prog = document.getElementById(currentIETab + '-progress');
  prog.style.display = 'block';

  const fullItems = items.filter(i => i.mdId);
  const lookupItems = items.filter(i => !i.mdId);

  for (const item of fullItems) {
    if (lib.find(m => m.mdId && m.mdId === item.mdId)) continue;
    lib.push({ id: uid(), title: item.title, mdId: item.mdId || '', customUrl: item.customUrl || '', cover: item.cover || '', seriesStatus: item.seriesStatus || 'ongoing', type: item.type || 'manga', readingStatus: item.readingStatus || 'reading', chRead: item.chRead || 0, chLatest: item.chLatest || 0, hasNew: (item.chLatest||0) > (item.chRead||0), addedAt: Date.now() });
  }
  saveLib(); renderLib();

  const BATCH = 3;
  let added = fullItems.length;
  for (let i = 0; i < lookupItems.length; i += BATCH) {
    const batch = lookupItems.slice(i, i + BATCH);
    prog.textContent = 'Looking up ' + (i+1) + '‚Äì' + Math.min(i+BATCH, lookupItems.length) + ' of ' + lookupItems.length + '‚Ä¶';
    await Promise.all(batch.map(async item => {
      try {
        const results = await searchMD(item.title);
        const match = results[0];
        if (match) {
          const title = match.attributes.title.en || Object.values(match.attributes.title)[0] || item.title;
          const mdId = match.id;
          const type = item.type || mdType(match);
          const seriesStatus = match.attributes.status || 'ongoing';
          let cover = coverUrl(match) || '';
          if (!cover) { try { const d = await mdFetch('/manga/' + mdId + '?includes[]=cover_art'); cover = coverUrl(d.data) || ''; } catch {} }
          const r = await getLatestCh(mdId, item.customUrl || '');
          lib.push({ id: uid(), title, mdId, customUrl: item.customUrl || '', cover, seriesStatus, type, readingStatus: item.readingStatus || 'reading', chRead: item.chRead || 0, chLatest: r?.ch || 0, chSource: r?.source || '', hasNew: (r?.ch||0) > (item.chRead||0), addedAt: Date.now() });
        } else {
          lib.push({ id: uid(), title: item.title, mdId: '', customUrl: item.customUrl || '', cover: '', seriesStatus: 'ongoing', type: item.type || 'manga', readingStatus: item.readingStatus || 'reading', chRead: item.chRead || 0, chLatest: 0, hasNew: false, addedAt: Date.now() });
        }
        added++;
        saveLib();
      } catch {}
    }));
    renderLib();
    if (i + BATCH < lookupItems.length) await sleep(400);
  }

  prog.textContent = '‚úì Done! Added ' + added + ' manga.';
  renderLib();
  showToast('Imported ' + added + ' manga ‚úì');
  btn.disabled = false;
  setTimeout(() => { if (added > 0) closeImport(); }, 1500);
}

function onDragOver(e) { e.preventDefault(); document.getElementById('drop-zone').classList.add('drag-over'); }
function onDragLeave(e) { document.getElementById('drop-zone').classList.remove('drag-over'); }
function onDrop(e) { e.preventDefault(); document.getElementById('drop-zone').classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) processFile(file); }
function onFileSelect(e) { if (e.target.files[0]) processFile(e.target.files[0]); }

function processFile(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      if (file.name.endsWith('.json')) parseJSONImport(e.target.result);
      else parseCSVImport(e.target.result);
    } catch(err) { showToast('Could not parse file: ' + err.message, 'err'); }
  };
  reader.readAsText(file);
}

function parseJSONImport(content) {
  const data = JSON.parse(content);
  const items = Array.isArray(data) ? data : data.library || data.lib || [];
  importQueue = items.map(item => {
    const title = item.title || item.name || '';
    if (!title) return null;
    const existing = lib.find(m => m.title.toLowerCase() === title.toLowerCase());
    return { title, chRead: parseFloat(item.chRead) || 0, chLatest: parseFloat(item.chLatest) || 0, type: item.type || 'manga', readingStatus: item.readingStatus || 'reading', mdId: item.mdId || '', customUrl: item.customUrl || '', cover: item.cover || '', seriesStatus: item.seriesStatus || 'ongoing', status: existing ? 'dup' : 'ok' };
  }).filter(Boolean);
  renderImportPreview('file-preview');
}

function parseCSVImport(content) {
  const lines = content.trim().split('\n');
  const header = lines[0].toLowerCase().split(',').map(h => h.trim().replace(/"/g,''));
  const idx = name => header.findIndex(h => h.includes(name));
  const ti = idx('title'), ci = idx('chread'), li = idx('latest'), tyi = idx('type'), si = idx('status');
  importQueue = lines.slice(1).map(line => {
    const cols = line.split(',').map(c => c.trim().replace(/"/g,''));
    const title = ti >= 0 ? cols[ti] : cols[0];
    if (!title) return null;
    const existing = lib.find(m => m.title.toLowerCase() === title.toLowerCase());
    return { title, chRead: parseFloat(ci >= 0 ? cols[ci] : cols[1]) || 0, chLatest: parseFloat(li >= 0 ? cols[li] : 0) || 0, type: tyi >= 0 ? cols[tyi] : 'manga', readingStatus: si >= 0 ? cols[si] : 'reading', status: existing ? 'dup' : 'ok' };
  }).filter(Boolean);
  renderImportPreview('file-preview');
}

async function bulkMDImport() {
  const raw = document.getElementById('bulk-input').value.trim();
  if (!raw) { showToast('Paste some MangaDex IDs first!', 'err'); return; }
  const ids = raw.split('\n').map(l => l.trim()).filter(l => l.length > 10);
  if (!ids.length) { showToast('No valid IDs found', 'err'); return; }
  const prog = document.getElementById('bulk-progress');
  prog.style.display = 'block';
  let added = 0;
  for (let i = 0; i < ids.length; i++) {
    const mdId = ids[i];
    prog.textContent = 'Fetching ' + (i+1) + '/' + ids.length + '‚Ä¶';
    if (lib.find(m => m.mdId === mdId)) { await sleep(200); continue; }
    try {
      const d = await mdFetch('/manga/' + mdId + '?includes[]=cover_art');
      const manga = d.data;
      const title = manga.attributes.title.en || Object.values(manga.attributes.title)[0] || mdId;
      const type = mdType(manga);
      const cover = coverUrl(manga) || '';
      const seriesStatus = manga.attributes.status || 'ongoing';
      const r = await getLatestCh(mdId, '');
      lib.push({ id: uid(), title, mdId, customUrl: '', cover, seriesStatus, type, readingStatus: 'reading', chRead: 0, chLatest: r?.ch || 0, chSource: r?.source || '', hasNew: (r?.ch||0) > 0, addedAt: Date.now() });
      added++; saveLib();
    } catch {}
    await sleep(500);
  }
  prog.textContent = '‚úì Done! Added ' + added + ' manga.';
  renderLib();
  showToast('Bulk imported ' + added + ' manga ‚úì');
  setTimeout(() => { if (added > 0) closeImport(); }, 1500);
}

function exportJSON() {
  const data = lib.map(m => ({ title: m.title, type: m.type, readingStatus: m.readingStatus, chRead: m.chRead || 0, chLatest: m.chLatest || 0, mdId: m.mdId || '', customUrl: m.customUrl || '', seriesStatus: m.seriesStatus || 'ongoing', cover: m.cover || '' }));
  downloadFile('mangatrack-library.json', JSON.stringify(data, null, 2), 'application/json');
  showToast('JSON exported ‚úì');
}
function exportCSV() {
  const header = 'title,type,readingStatus,chRead,chLatest,mdId,seriesStatus';
  const rows = lib.map(m => [m.title, m.type, m.readingStatus, m.chRead||0, m.chLatest||0, m.mdId||'', m.seriesStatus||'ongoing'].map(v => '"' + String(v).replace(/"/g,'""') + '"').join(','));
  downloadFile('mangatrack-library.csv', [header, ...rows].join('\n'), 'text/csv');
  showToast('CSV exported ‚úì');
}
function exportText() {
  downloadFile('mangatrack-library.txt', lib.map(m => m.title + ' (Ch.' + (m.chRead||0) + '/' + (m.chLatest||'?') + ')').join('\n'), 'text/plain');
  showToast('Text list exported ‚úì');
}
function downloadFile(name, content, mime) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([content], { type: mime }));
  a.download = name; a.click();
  URL.revokeObjectURL(a.href);
}

// ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showToast(msg, type) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast' + (type === 'err' ? ' err' : '') + ' show';
  clearTimeout(t._t);
  t._t = setTimeout(() => t.classList.remove('show'), 3500);
}
function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

// ‚îÄ‚îÄ EVENT LISTENERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('modal').addEventListener('click', e => { if (e.target===e.currentTarget) closeModal(); });
document.getElementById('import-modal').addEventListener('click', e => { if (e.target===e.currentTarget) closeImport(); });
document.getElementById('export-modal').addEventListener('click', e => { if (e.target===e.currentTarget) closeExport(); });
document.getElementById('debug-modal').addEventListener('click', e => { if (e.target===e.currentTarget) e.currentTarget.classList.remove('open'); });
document.addEventListener('click', e => {
  const r = document.getElementById('md-results');
  if (r && !r.contains(e.target) && e.target.id !== 'md-search') r.classList.remove('open');
});

// ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('panel-library').style.display = 'block';
// Set theme button icon correctly
const _themeBtn = document.getElementById('themeBtn');
if (_themeBtn && document.body.classList.contains('light')) _themeBtn.textContent = 'üåô';
renderLib();
setInterval(checkAllUpdates, 60 * 60 * 1000);
</script>
</body>
</html>