<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="referrer" content="no-referrer">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MangaTrack â€” Real Chapter Updates</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700;900&family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300&family=Bebas+Neue&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0f;
  --surface: #111118;
  --card: #15151e;
  --border: #252535;
  --accent: #e8385a;
  --accent2: #ff9f43;
  --accent3: #00d2d3;
  --text: #e8e8f0;
  --muted: #5c5c7a;
  --success: #26de81;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'DM Mono', monospace;
  min-height: 100vh;
}
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(ellipse 60% 40% at 15% 15%, rgba(232,56,90,.07) 0%, transparent 60%),
    radial-gradient(ellipse 50% 40% at 85% 85%, rgba(0,210,211,.05) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}
.wrap { max-width: 1200px; margin: 0 auto; padding: 0 24px; position: relative; z-index: 1; }

header { padding: 28px 0 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; }
.logo-title { font-family: 'Bebas Neue', sans-serif; font-size: 40px; letter-spacing: 5px; line-height: 1; }
.logo-title span { color: var(--accent); }
.logo-sub { font-size: 9px; color: var(--muted); letter-spacing: 3px; text-transform: uppercase; margin-top: 2px; }
.header-right { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

.btn {
  font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 2px;
  text-transform: uppercase; padding: 9px 18px; cursor: pointer; border: none;
  transition: all .2s; display: inline-flex; align-items: center; gap: 7px;
}
.btn-outline { background: transparent; border: 1px solid var(--border); color: var(--muted); }
.btn-outline:hover { border-color: var(--accent3); color: var(--accent3); }
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: #ff1f44; transform: translateY(-1px); }
.btn-sm { padding: 6px 12px; font-size: 9px; }
.btn.spinning .spin-icon { animation: spin .6s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
.spin-icon { display: inline-block; }

.stats { display: flex; gap: 28px; padding: 16px 0; border-bottom: 1px solid var(--border); flex-wrap: wrap; }
.stat { display: flex; flex-direction: column; gap: 2px; }
.stat-val { font-family: 'Bebas Neue', sans-serif; font-size: 30px; line-height: 1; }
.c1{color:var(--text)} .c2{color:var(--accent3)} .c3{color:var(--accent2)} .c4{color:var(--accent)}
.stat-label { font-size: 9px; color: var(--muted); letter-spacing: 2px; text-transform: uppercase; }

.tabs { display: flex; border-bottom: 1px solid var(--border); }
.tab { background: none; border: none; color: var(--muted); font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; padding: 14px 18px; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -1px; transition: all .2s; }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab:hover:not(.active) { color: var(--text); }
.tab-badge { display: inline-block; background: var(--accent3); color: #000; font-size: 8px; padding: 1px 5px; border-radius: 999px; margin-left: 4px; vertical-align: middle; font-weight: 700; }

.toolbar { display: flex; gap: 10px; padding: 18px 0; align-items: center; flex-wrap: wrap; }
.search-wrap { position: relative; flex: 1; min-width: 180px; }
.search-wrap input { width: 100%; background: var(--surface); border: 1px solid var(--border); color: var(--text); padding: 9px 14px 9px 34px; font-family: 'DM Mono', monospace; font-size: 11px; outline: none; transition: border-color .2s; }
.search-wrap input:focus { border-color: var(--accent); }
.search-wrap input::placeholder { color: var(--muted); }
.search-icon { position: absolute; left: 11px; top: 50%; transform: translateY(-50%); color: var(--muted); font-size: 13px; pointer-events: none; }
.flt { background: var(--surface); border: 1px solid var(--border); color: var(--text); padding: 9px 12px; font-family: 'DM Mono', monospace; font-size: 10px; outline: none; cursor: pointer; letter-spacing: 1px; }

.grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px; padding-bottom: 60px; }
.card { background: var(--card); border: 1px solid var(--border); position: relative; overflow: hidden; transition: all .22s; animation: fadeUp .3s ease both; }
@keyframes fadeUp { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:translateY(0)} }
.card:hover { border-color: var(--accent); transform: translateY(-2px); box-shadow: 0 10px 40px rgba(232,56,90,.12); }
.card.has-new { border-color: var(--accent3); }
.card.has-new::after { content:''; position:absolute; top:0; left:0; right:0; height:2px; background:var(--accent3); }
.new-pill { position:absolute; top:10px; right:10px; background:var(--accent3); color:#000; font-size:8px; font-weight:700; padding:2px 8px; letter-spacing:2px; text-transform:uppercase; animation:glow 2s infinite; }
@keyframes glow { 0%,100%{box-shadow:0 0 6px rgba(0,210,211,.5)} 50%{box-shadow:0 0 14px rgba(0,210,211,.9)} }
.card-cover { width:100%; height:150px; object-fit:cover; display:block; background:var(--surface); }
.cover-ph { width:100%; height:150px; background:linear-gradient(135deg,var(--surface),var(--border)); display:flex; align-items:center; justify-content:center; font-family:'Noto Serif JP',serif; font-size:52px; color:var(--border); }
.card-body { padding:12px 14px; }
.card-type { font-size:8px; letter-spacing:3px; text-transform:uppercase; margin-bottom:5px; }
.type-manga{color:var(--accent)} .type-manhua{color:var(--accent2)} .type-manhwa{color:var(--accent3)}
.card-title { font-family:'Noto Serif JP',serif; font-size:14px; font-weight:700; line-height:1.35; margin-bottom:10px; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }
.card-meta { display:flex; justify-content:space-between; align-items:flex-end; }
.ch-read { font-size:10px; color:var(--muted); }
.ch-latest { font-size:12px; color:var(--text); margin-top:2px; }
.ch-latest.new { color:var(--accent3); }
.card-actions { display:flex; gap:5px; }
.icon-btn { background:var(--surface); border:1px solid var(--border); color:var(--muted); width:28px; height:28px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:12px; transition:all .15s; }
.icon-btn:hover { border-color:var(--accent); color:var(--accent); }
.icon-btn.del:hover { border-color:#f55; color:#f55; }
.card-foot { margin-top:8px; font-size:9px; color:var(--muted); display:flex; align-items:center; gap:5px; }
.dot { width:6px; height:6px; border-radius:50%; flex-shrink:0; }
.dot.ongoing{background:var(--accent3)} .dot.completed{background:var(--muted)} .dot.hiatus{background:var(--accent2)} .dot.cancelled{background:#f55}
.card-source { font-size:8px; color:var(--muted); opacity:.5; margin-top:3px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; letter-spacing:.5px; }

.empty { grid-column:1/-1; text-align:center; padding:80px 24px; }
.empty-icon { font-size:60px; opacity:.15; margin-bottom:14px; }
.empty-title { font-family:'Bebas Neue',sans-serif; font-size:26px; letter-spacing:4px; color:var(--muted); margin-bottom:6px; }
.empty-sub { font-size:10px; color:var(--muted); letter-spacing:1px; }

.overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,.85); z-index:200; backdrop-filter:blur(6px); align-items:center; justify-content:center; padding:20px; }
.overlay.open { display:flex; }
.modal { background:var(--card); border:1px solid var(--border); width:100%; max-width:520px; animation:slideUp .25s ease; max-height:90vh; overflow-y:auto; }
@keyframes slideUp { from{opacity:0;transform:translateY(20px)} to{opacity:1;transform:translateY(0)} }
.modal-hd { padding:18px 22px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; position:sticky; top:0; background:var(--card); z-index:2; }
.modal-title { font-family:'Bebas Neue',sans-serif; font-size:22px; letter-spacing:3px; }
.close-btn { background:none; border:none; color:var(--muted); font-size:18px; cursor:pointer; transition:color .15s; }
.close-btn:hover { color:var(--accent); }
.modal-body { padding:20px 22px; display:flex; flex-direction:column; gap:14px; }
.form-group { display:flex; flex-direction:column; gap:5px; }
.form-label { font-size:9px; letter-spacing:2px; text-transform:uppercase; color:var(--muted); }
.form-input, .form-select { background:var(--surface); border:1px solid var(--border); color:var(--text); padding:9px 12px; font-family:'DM Mono',monospace; font-size:11px; outline:none; width:100%; transition:border-color .2s; }
.form-input:focus,.form-select:focus { border-color:var(--accent); }
.form-input::placeholder { color:var(--muted); }
.form-row { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
.modal-ft { padding:14px 22px; border-top:1px solid var(--border); display:flex; justify-content:flex-end; gap:8px; position:sticky; bottom:0; background:var(--card); }

.md-results { border:1px solid var(--border); border-top:none; background:var(--surface); max-height:220px; overflow-y:auto; display:none; }
.md-results.open { display:block; }
.sr-item { display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border); transition:background .15s; }
.sr-item:last-child { border-bottom:none; }
.sr-item:hover { background:var(--card); }
.sr-thumb { width:36px; height:48px; object-fit:cover; background:var(--border); flex-shrink:0; }
.sr-ph { width:36px; height:48px; background:var(--border); display:flex; align-items:center; justify-content:center; font-size:16px; flex-shrink:0; }
.sr-info { flex:1; min-width:0; }
.sr-name { font-size:12px; font-weight:500; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.sr-meta { font-size:9px; color:var(--muted); margin-top:2px; letter-spacing:1px; text-transform:uppercase; }
.sr-msg { padding:14px; text-align:center; color:var(--muted); font-size:10px; letter-spacing:2px; }
.sr-msg.loading { animation:pulse 1s infinite; }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.4} }

.update-panel { display:none; padding-bottom:60px; }
.update-panel.active { display:block; }
.log-toolbar { display:flex; align-items:center; justify-content:space-between; padding:16px 0 12px; }
.log-label { font-size:9px; letter-spacing:2px; color:var(--muted); text-transform:uppercase; }
.log-entry { display:flex; align-items:center; gap:14px; border-left:2px solid var(--border); padding:12px 18px; margin-bottom:10px; background:var(--card); transition:border-color .2s; }
.log-entry.unread { border-left-color:var(--accent3); }
.log-cover { width:36px; height:48px; object-fit:cover; background:var(--border); flex-shrink:0; }
.log-cover-ph { width:36px; height:48px; background:linear-gradient(135deg,var(--surface),var(--border)); display:flex; align-items:center; justify-content:center; font-size:16px; flex-shrink:0; }
.log-info { flex:1; min-width:0; }
.log-title-txt { font-family:'Noto Serif JP',serif; font-size:13px; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.log-ch { font-size:11px; color:var(--accent3); margin-top:3px; }
.log-time { font-size:9px; color:var(--muted); text-align:right; white-space:nowrap; }

.toast { position:fixed; bottom:24px; right:24px; background:var(--accent3); color:#000; padding:11px 20px; font-size:10px; letter-spacing:1.5px; font-weight:600; z-index:999; transform:translateY(70px); opacity:0; transition:all .3s; text-transform:uppercase; max-width:340px; }
.toast.show { transform:translateY(0); opacity:1; }
.toast.err { background:var(--accent); color:#fff; }

.info-note { background:var(--surface); border:1px solid var(--border); border-left:3px solid var(--accent3); padding:10px 14px; font-size:10px; color:var(--muted); line-height:1.6; letter-spacing:.5px; }
.info-note strong { color:var(--accent3); }

@media(max-width:600px){.logo-title{font-size:30px}.stats{gap:16px}.form-row{grid-template-columns:1fr}.grid{grid-template-columns:1fr 1fr}}
@media(max-width:400px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <div class="logo-title">MANGA<span>TRACK</span></div>
      <div class="logo-sub">Live updates via MangaDex API</div>
    </div>
    <div class="header-right">
      <button class="btn btn-outline" id="checkBtn" onclick="checkAllUpdates()">
        <span class="spin-icon">â†»</span> CHECK UPDATES
      </button>
      <button class="btn btn-primary" onclick="openAdd()">+ ADD</button>
    </div>
  </header>

  <div class="stats">
    <div class="stat"><div class="stat-val c1" id="s-total">0</div><div class="stat-label">Tracking</div></div>
    <div class="stat"><div class="stat-val c2" id="s-new">0</div><div class="stat-label">New Chapters</div></div>
    <div class="stat"><div class="stat-val c3" id="s-reading">0</div><div class="stat-label">Reading</div></div>
    <div class="stat"><div class="stat-val c4" id="s-completed">0</div><div class="stat-label">Completed</div></div>
  </div>

  <div class="tabs">
    <button class="tab active" id="tab-lib" onclick="switchTab('library')">Library</button>
    <button class="tab" id="tab-upd" onclick="switchTab('updates')">Updates <span id="upd-badge" class="tab-badge" style="display:none"></span></button>
  </div>

  <!-- LIBRARY -->
  <div id="panel-library">
    <div class="toolbar">
      <div class="search-wrap">
        <span class="search-icon">âŒ•</span>
        <input type="text" id="q" placeholder="Filter library..." oninput="renderLib()">
      </div>
      <select class="flt" id="flt-type" onchange="renderLib()">
        <option value="">All Types</option>
        <option value="manga">Manga</option>
        <option value="manhua">Manhua</option>
        <option value="manhwa">Manhwa</option>
      </select>
      <select class="flt" id="flt-status" onchange="renderLib()">
        <option value="">All Status</option>
        <option value="reading">Reading</option>
        <option value="completed">Completed</option>
        <option value="on-hold">On Hold</option>
        <option value="dropped">Dropped</option>
        <option value="plan">Plan to Read</option>
      </select>
    </div>
    <div class="grid" id="grid"></div>
  </div>

  <!-- UPDATES -->
  <div class="update-panel" id="panel-updates">
    <div class="log-toolbar">
      <span class="log-label">Recent Chapter Updates</span>
      <button class="btn btn-outline btn-sm" onclick="markAllRead()">Mark All Read</button>
    </div>
    <div id="log-list"></div>
  </div>
</div>

<!-- MODAL -->
<div class="overlay" id="modal">
  <div class="modal">
    <div class="modal-hd">
      <div class="modal-title" id="modal-title">ADD MANGA</div>
      <button class="close-btn" onclick="closeModal()">âœ•</button>
    </div>
    <div class="modal-body">
      <div class="info-note">
        <strong>How it works:</strong> Search for a title below to auto-fill from MangaDex. The app will then fetch real chapter data when you click "Check Updates".
      </div>

      <div class="form-group" id="search-section">
        <label class="form-label">Search on MangaDex</label>
        <input class="form-input" id="md-search" placeholder="Type title to search live..." oninput="onMDSearch(event)" autocomplete="off">
        <div class="md-results" id="md-results"></div>
      </div>

      <div style="height:1px;background:var(--border)"></div>

      <div class="form-group">
        <label class="form-label">Title</label>
        <input class="form-input" id="f-title" placeholder="Title (auto-filled from search)">
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Type</label>
          <select class="form-select" id="f-type">
            <option value="manga">Manga ðŸ‡¯ðŸ‡µ</option>
            <option value="manhua">Manhua ðŸ‡¨ðŸ‡³</option>
            <option value="manhwa">Manhwa ðŸ‡°ðŸ‡·</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Reading Status</label>
          <select class="form-select" id="f-rstatus">
            <option value="reading">Reading</option>
            <option value="completed">Completed</option>
            <option value="on-hold">On Hold</option>
            <option value="dropped">Dropped</option>
            <option value="plan">Plan to Read</option>
          </select>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Chapter Read</label>
          <input class="form-input" id="f-chread" type="number" min="0" step="0.1" placeholder="0">
        </div>
        <div class="form-group">
          <label class="form-label">Latest Ch. <span style="color:var(--accent3);font-size:8px">auto</span></label>
          <input class="form-input" id="f-chlatest" type="number" min="0" step="0.1" placeholder="auto-fetched">
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">MangaDex ID <span style="color:var(--muted);font-size:8px">(auto from search â€” required for live updates)</span></label>
        <input class="form-input" id="f-mdid" placeholder="e.g. a1c7c817-4e59-43b7-9365-09675a149a6f">
      </div>
    </div>
    <div class="modal-ft">
      <button class="btn btn-outline" onclick="closeModal()">Cancel</button>
      <button class="btn btn-primary" onclick="save()">SAVE</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
// â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Using corsproxy.io â€” free CORS proxy, works for MangaDex API calls from browser
const PROXY = 'https://corsproxy.io/?';
const MD = 'https://api.mangadex.org';
const COVERS = 'https://uploads.mangadex.org/covers';
const COMICK = 'https://api.comick.fun';

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lib = JSON.parse(localStorage.getItem('mgt2_lib') || '[]');
let updLog = JSON.parse(localStorage.getItem('mgt2_log') || '[]');
let editId = null;
let mdTimer = null;

function saveLib() { localStorage.setItem('mgt2_lib', JSON.stringify(lib)); }
function saveLog() { localStorage.setItem('mgt2_log', JSON.stringify(updLog)); }
function uid() { return Math.random().toString(36).slice(2, 10); }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// â”€â”€ API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function mdFetch(path) {
  const url = PROXY + encodeURIComponent(MD + path);
  const res = await fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

async function searchMD(title) {
  const d = await mdFetch(`/manga?title=${encodeURIComponent(title)}&limit=8&includes[]=cover_art&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic`);
  return d.data || [];
}

async function getLatestCh(mdId, title = '') {
  // â”€â”€ MangaDex: aggregate (all languages) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mdAggregate = (async () => {
    try {
      const d = await mdFetch(`/manga/${mdId}/aggregate`);
      const chNums = [];
      for (const vol of Object.values(d.volumes || {}))
        for (const ch of Object.values(vol.chapters || {})) {
          const n = parseFloat(ch.chapter);
          if (!isNaN(n) && n > 0) chNums.push(n);
        }
      if (chNums.length) return Math.max(...chNums);
    } catch {}
    return null;
  })();

  // â”€â”€ MangaDex: feed endpoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mdFeed = (async () => {
    try {
      const path = `/manga/${mdId}/feed?limit=96&order[chapter]=desc&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic`;
      const d = await mdFetch(path);
      const chNums = (d.data || [])
        .map(c => parseFloat(c.attributes?.chapter))
        .filter(n => !isNaN(n) && n > 0);
      if (chNums.length) return Math.max(...chNums);
    } catch {}
    return null;
  })();

  // â”€â”€ MangaDex: lastChapter attribute â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mdAttr = (async () => {
    try {
      const d = await mdFetch(`/manga/${mdId}`);
      const last = parseFloat(d.data?.attributes?.lastChapter);
      if (!isNaN(last) && last > 0) return last;
    } catch {}
    return null;
  })();

  // â”€â”€ ComicK: search by MangaDex UUID (their API supports this) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const comickLatest = (async () => {
    try {
      // ComicK supports lookup by MangaDex UUID via their /comic endpoint
      const infoUrl = PROXY + encodeURIComponent(`${COMICK}/comic/${mdId}`);
      const ir = await fetch(infoUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      if (ir.ok) {
        const info = await ir.json();
        const slug = info?.comic?.slug || info?.slug;
        if (slug) {
          // Get chapters sorted desc, no lang filter to catch all scanlations
          const chapUrl = PROXY + encodeURIComponent(`${COMICK}/comic/${slug}/chapters?limit=1&page=1&chap-order=desc`);
          const cr = await fetch(chapUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
          if (cr.ok) {
            const chapData = await cr.json();
            const chap = parseFloat(chapData?.chapters?.[0]?.chap);
            if (!isNaN(chap) && chap > 0) return chap;
          }
        }
      }
      // Fallback: search ComicK by title
      if (title) {
        const sq = PROXY + encodeURIComponent(`${COMICK}/v1.0/search?q=${encodeURIComponent(title)}&limit=5`);
        const sr = await fetch(sq, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
        if (sr.ok) {
          const results = await sr.json();
          const slug = results?.[0]?.slug;
          if (slug) {
            const chapUrl = PROXY + encodeURIComponent(`${COMICK}/comic/${slug}/chapters?limit=1&page=1&chap-order=desc`);
            const cr = await fetch(chapUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
            if (cr.ok) {
              const chapData = await cr.json();
              const chap = parseFloat(chapData?.chapters?.[0]?.chap);
              if (!isNaN(chap) && chap > 0) return chap;
            }
          }
        }
      }
    } catch {}
    return null;
  })();

  // â”€â”€ MangaTown scrape: reliable third-party aggregator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mangaTownLatest = (async () => {
    if (!title) return null;
    try {
      // Build slug: lowercase, spaces â†’ underscores, strip special chars
      const slug = title.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim().replace(/\s+/g, '_');
      const url = PROXY + encodeURIComponent(`https://www.mangatown.com/manga/${slug}/`);
      const res = await fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      if (!res.ok) return null;
      const html = await res.text();
      // Chapter list items look like: <li><a href=".../c063/">Chapter 63</a>
      const matches = [...html.matchAll(/Chapter\s+([\d.]+)/gi)];
      const nums = matches.map(m => parseFloat(m[1])).filter(n => !isNaN(n) && n > 0);
      if (nums.length) return Math.max(...nums);
    } catch {}
    return null;
  })();

  // â”€â”€ Bato.to: another reliable aggregator with a search API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const batoLatest = (async () => {
    if (!title) return null;
    try {
      const searchUrl = PROXY + encodeURIComponent(`https://bato.to/search?word=${encodeURIComponent(title)}&lang=en`);
      const res = await fetch(searchUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      if (!res.ok) return null;
      const html = await res.text();
      // Find first series link
      const seriesMatch = html.match(/href="(\/title\/\d+[^"]+)"/);
      if (!seriesMatch) return null;
      const seriesUrl = PROXY + encodeURIComponent('https://bato.to' + seriesMatch[1]);
      const sr = await fetch(seriesUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      if (!sr.ok) return null;
      const shtml = await sr.text();
      const cmatches = [...shtml.matchAll(/ch[._-]?([\d]+(?:\.\d+)?)/gi)];
      const nums = cmatches.map(m => parseFloat(m[1])).filter(n => !isNaN(n) && n > 0);
      if (nums.length) return Math.max(...nums);
    } catch {}
    return null;
  })();

  // Run all in parallel, return the highest value found across all sources
  const results = await Promise.all([mdAggregate, mdFeed, mdAttr, comickLatest, mangaTownLatest, batoLatest]);
  const valid = results.filter(v => v !== null && v > 0);
  if (valid.length) return Math.max(...valid);
  return null;
}

function coverUrl(manga) {
  const rel = (manga.relationships || []).find(r => r.type === 'cover_art');
  if (!rel?.attributes?.fileName) return null;
  
  // Construct the original MangaDex image URL
  const imageUrl = `${COVERS}/${manga.id}/${rel.attributes.fileName}.256.jpg`;
  
  // Wrap it in the proxy just like the mdFetch function does
  return PROXY + encodeURIComponent(imageUrl);
}

function mdType(manga) {
  const lang = manga.attributes?.originalLanguage;
  if (lang === 'zh' || lang === 'zh-hk') return 'manhua';
  if (lang === 'ko') return 'manhwa';
  return 'manga';
}

// â”€â”€ RENDER LIBRARY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderLib() {
  const grid = document.getElementById('grid');
  const q = document.getElementById('q').value.toLowerCase();
  const ft = document.getElementById('flt-type').value;
  const fs = document.getElementById('flt-status').value;

  let items = lib.filter(m => {
    if (q && !m.title.toLowerCase().includes(q)) return false;
    if (ft && m.type !== ft) return false;
    if (fs && m.readingStatus !== fs) return false;
    return true;
  }).sort((a, b) => (b.hasNew - a.hasNew) || (b.addedAt - a.addedAt));

  if (!items.length) {
    grid.innerHTML = `<div class="empty">
      <div class="empty-icon">ðŸ“š</div>
      <div class="empty-title">${lib.length ? 'No Results' : 'Empty Library'}</div>
      <div class="empty-sub">${lib.length ? 'Try different filters' : 'Click + ADD and search for manga'}</div>
    </div>`;
    return updateStats();
  }

  grid.innerHTML = items.map(m => {
    const hasNew = m.hasNew && (m.chLatest || 0) > (m.chRead || 0);
    const ss = m.seriesStatus || 'ongoing';
    const rlabel = {reading:'Reading',completed:'Completed','on-hold':'On Hold',dropped:'Dropped',plan:'Plan to Read'}[m.readingStatus] || m.readingStatus;
    const slabel = {ongoing:'Ongoing',completed:'Completed',hiatus:'Hiatus',cancelled:'Cancelled'}[ss] || ss;
    return `<div class="card${hasNew?' has-new':''}" id="card-${m.id}">
      ${hasNew ? '<div class="new-pill">New Ch.</div>' : ''}
      ${m.cover ? `<img class="card-cover" src="${esc(m.cover)}" loading="lazy" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'" alt="">` : ''}
      <div class="cover-ph"${m.cover ? ' style="display:none"' : ''}>${m.title.charAt(0).toUpperCase()}</div>
      <div class="card-body">
        <div class="card-type type-${m.type}">${m.type.toUpperCase()}</div>
        <div class="card-title">${esc(m.title)}</div>
        <div class="card-meta">
          <div>
            <div class="ch-read">Read: Ch.${m.chRead || 0}</div>
            <div class="ch-latest${hasNew?' new':''}">Latest: Ch.${m.chLatest ?? '?'}${hasNew?' â†‘':''}</div>
          </div>
          <div class="card-actions">
            <button class="icon-btn" title="Mark chapter read" onclick="markRead('${m.id}')">âœ“</button>
            <button class="icon-btn" title="Edit" onclick="openEdit('${m.id}')">âœŽ</button>
            <button class="icon-btn del" title="Remove" onclick="del('${m.id}')">âœ•</button>
          </div>
        </div>
        <div class="card-foot"><span class="dot ${ss}"></span>${slabel} Â· ${rlabel}</div>
        ${m.mdId ? `<div class="card-source">MDex: ${m.mdId.slice(0,16)}â€¦</div>` : '<div class="card-source" style="color:var(--accent);opacity:.6">âš  No MangaDex ID â€” no live updates</div>'}
      </div>
    </div>`;
  }).join('');

  updateStats();
}

function updateStats() {
  document.getElementById('s-total').textContent = lib.length;
  document.getElementById('s-new').textContent = lib.filter(m => m.hasNew && (m.chLatest||0) > (m.chRead||0)).length;
  document.getElementById('s-reading').textContent = lib.filter(m => m.readingStatus === 'reading').length;
  document.getElementById('s-completed').textContent = lib.filter(m => m.readingStatus === 'completed').length;
  const unread = updLog.filter(u => !u.read).length;
  const badge = document.getElementById('upd-badge');
  badge.style.display = unread ? 'inline' : 'none';
  badge.textContent = unread;
}

// â”€â”€ RENDER UPDATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderLog() {
  const list = document.getElementById('log-list');
  if (!updLog.length) {
    list.innerHTML = `<div class="empty" style="padding:60px 0">
      <div class="empty-icon">ðŸ””</div>
      <div class="empty-title">No Updates Yet</div>
      <div class="empty-sub">Click "Check Updates" to fetch real data</div>
    </div>`;
    return;
  }
  list.innerHTML = [...updLog].sort((a,b)=>b.time-a.time).map(u => `
    <div class="log-entry${u.read?'':' unread'}">
      ${u.cover
        ? `<img class="log-cover" src="${esc(u.cover)}" loading="lazy" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'" alt=""><div class="log-cover-ph" style="display:none">${u.title.charAt(0)}</div>`
        : `<div class="log-cover-ph">${u.title.charAt(0)}</div>`}
      <div class="log-info">
        <div class="log-title-txt">${esc(u.title)}</div>
        <div class="log-ch">Ch.${u.oldCh} â†’ Ch.${u.newCh} <span style="color:var(--muted);font-size:9px">(+${(u.newCh-u.oldCh).toFixed(1).replace(/\.0$/,'')})</span></div>
      </div>
      <div class="log-time">${timeAgo(u.time)}</div>
    </div>`).join('');
}

function timeAgo(ts) {
  const d = Date.now() - ts, m = Math.floor(d/60000);
  if (m < 1) return 'just now';
  if (m < 60) return m + 'm ago';
  const h = Math.floor(m/60);
  if (h < 24) return h + 'h ago';
  return Math.floor(h/24) + 'd ago';
}

// â”€â”€ CHECK UPDATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function checkAllUpdates() {
  const tracked = lib.filter(m => m.mdId);
  if (!tracked.length) {
    showToast('Add manga using Search to get MangaDex IDs for live updates!', 'err');
    return;
  }

  const btn = document.getElementById('checkBtn');
  btn.classList.add('spinning');
  btn.disabled = true;

  let found = 0, errors = 0;
  showToast(`Checking ${tracked.length} manga via MangaDexâ€¦`);

  for (const m of tracked) {
    try {
      let latest = await getLatestCh(m.mdId, m.title);
      if (latest === null) { errors++; continue; }

      if (latest > (m.chLatest || 0)) {
        const old = m.chLatest || 0;
        m.chLatest = latest;
        m.hasNew = true;
        found++;
        updLog.unshift({ id: uid(), mangaId: m.id, title: m.title, type: m.type, oldCh: old, newCh: latest, cover: m.cover || '', time: Date.now(), read: false });
      } else {
        // Update stored latest in case we had wrong info
        if (latest > 0 && (!m.chLatest || latest > m.chLatest)) {
          m.chLatest = latest;
        }
      }
      // Respect API rate limits
      await sleep(400);
    } catch (e) {
      errors++;
    }
  }

  updLog = updLog.slice(0, 100);
  saveLib();
  saveLog();
  renderLib();
  renderLog();
  btn.classList.remove('spinning');
  btn.disabled = false;

  if (found > 0) showToast(`ðŸŽ‰ ${found} new chapter update${found > 1 ? 's' : ''} found!`);
  else if (errors > 0) showToast(`Checked. ${errors} failed, rest up to date.`, 'err');
  else showToast('All up to date âœ“');
}

// â”€â”€ ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function markRead(id) {
  const m = lib.find(x => x.id === id);
  if (!m) return;
  if ((m.chLatest || 0) > (m.chRead || 0)) {
    m.chRead = m.chLatest;
    m.hasNew = false;
    saveLib(); renderLib();
    showToast(`Marked Ch.${m.chLatest} as read âœ“`);
  } else {
    showToast('Already up to date!');
  }
}

function del(id) {
  if (!confirm('Remove from library?')) return;
  lib = lib.filter(m => m.id !== id);
  saveLib(); renderLib();
  showToast('Removed.');
}

function markAllRead() {
  updLog.forEach(u => u.read = true);
  lib.forEach(m => { if (m.hasNew) { m.chRead = m.chLatest; m.hasNew = false; } });
  saveLib(); saveLog(); renderLib(); renderLog();
  showToast('All marked as read âœ“');
}

// â”€â”€ TABS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function switchTab(name) {
  ['lib','upd'].forEach(t => document.getElementById('tab-'+t).classList.remove('active'));
  document.getElementById('tab-' + (name==='library'?'lib':'upd')).classList.add('active');
  document.getElementById('panel-library').style.display = name==='library' ? 'block' : 'none';
  document.getElementById('panel-updates').classList.toggle('active', name==='updates');
  if (name === 'updates') renderLog();
}

// â”€â”€ MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openAdd() {
  editId = null;
  document.getElementById('modal-title').textContent = 'ADD MANGA';
  document.getElementById('search-section').style.display = '';
  clearForm();
  document.getElementById('modal').classList.add('open');
}

function openEdit(id) {
  const m = lib.find(x => x.id === id);
  if (!m) return;
  editId = id;
  document.getElementById('modal-title').textContent = 'EDIT MANGA';
  document.getElementById('search-section').style.display = 'none';
  document.getElementById('f-title').value = m.title;
  document.getElementById('f-type').value = m.type;
  document.getElementById('f-rstatus').value = m.readingStatus;
  document.getElementById('f-chread').value = m.chRead || '';
  document.getElementById('f-chlatest').value = m.chLatest || '';
  document.getElementById('f-mdid').value = m.mdId || '';
  document.getElementById('modal').classList.add('open');
}

function closeModal() {
  document.getElementById('modal').classList.remove('open');
  document.getElementById('md-results').classList.remove('open');
  clearTimeout(mdTimer);
}

function clearForm() {
  ['f-title','f-chread','f-chlatest','f-mdid','md-search'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  document.getElementById('f-type').value = 'manga';
  document.getElementById('f-rstatus').value = 'reading';
  const r = document.getElementById('md-results');
  r.classList.remove('open'); r.innerHTML = '';
}

// â”€â”€ MANGADEX LIVE SEARCH IN MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function onMDSearch(e) {
  clearTimeout(mdTimer);
  const val = e.target.value.trim();
  const results = document.getElementById('md-results');
  if (!val) { results.classList.remove('open'); return; }
  results.innerHTML = '<div class="sr-msg loading">SEARCHING MANGADEXâ€¦</div>';
  results.classList.add('open');
  mdTimer = setTimeout(async () => {
    try {
      const data = await searchMD(val);
      if (!data.length) {
        results.innerHTML = '<div class="sr-msg">No results found</div>';
        return;
      }
      results.innerHTML = data.map(m => {
        const title = m.attributes.title.en || Object.values(m.attributes.title)[0] || 'Unknown';
        const type = mdType(m);
        const status = m.attributes.status || 'ongoing';
        const cover = coverUrl(m);
        const lastCh = m.attributes.lastChapter;
        // Encode info as a JSON data attribute
        const info = JSON.stringify({ id: m.id, title, type, status, cover: cover||'', lastCh: lastCh||'' });
        return `<div class="sr-item" onclick='selectMD(${info.replace(/'/g,"&#39;")})'>
          ${cover ? `<img class="sr-thumb" src="${esc(cover)}" loading="lazy" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'" alt=""><div class="sr-ph" style="display:none">${title.charAt(0)}</div>` : `<div class="sr-ph">${title.charAt(0)}</div>`}
          <div class="sr-info">
            <div class="sr-name">${esc(title)}</div>
            <div class="sr-meta">${type} Â· ${status}${lastCh ? ' Â· Ch.'+lastCh : ''}</div>
          </div>
        </div>`;
      }).join('');
    } catch(err) {
      results.innerHTML = `<div class="sr-msg">Error: ${esc(err.message)}</div>`;
    }
  }, 600);
}

async function selectMD(info) {
  document.getElementById('f-title').value = info.title;
  document.getElementById('f-type').value = info.type;
  document.getElementById('f-mdid').value = info.id;
  // Prefer lastChapter from manga attributes (authoritative MangaDex count) if available
  if (info.lastCh) {
    const lc = parseFloat(info.lastCh);
    if (!isNaN(lc) && lc > 0) document.getElementById('f-chlatest').value = lc;
  }
  document.getElementById('md-results').classList.remove('open');
  document.getElementById('md-search').value = '';

  showToast('Fetching latest chapter from MangaDexâ€¦');
  try {
    const ch = await getLatestCh(info.id, info.title);
    if (ch !== null) {
      // Use whichever is higher: feed-based or lastChapter attribute
      const existing = parseFloat(document.getElementById('f-chlatest').value) || 0;
      document.getElementById('f-chlatest').value = Math.max(ch, existing) || ch;
      showToast(`Latest chapter: ${document.getElementById('f-chlatest').value} âœ“`);
    } else {
      showToast('Could not fetch chapter count', 'err');
    }
  } catch { showToast('Could not fetch chapter', 'err'); }
}

async function save() {
  const title = document.getElementById('f-title').value.trim();
  if (!title) { showToast('Title is required!', 'err'); return; }
  const mdId = document.getElementById('f-mdid').value.trim();
  const chRead = parseFloat(document.getElementById('f-chread').value) || 0;
  const chLatest = parseFloat(document.getElementById('f-chlatest').value) || chRead;

  if (editId) {
    const m = lib.find(x => x.id === editId);
    const oldLatest = m.chLatest || 0;
    Object.assign(m, {
      title, mdId,
      type: document.getElementById('f-type').value,
      readingStatus: document.getElementById('f-rstatus').value,
      chRead, chLatest
    });
    if (chLatest > oldLatest) {
      m.hasNew = true;
      updLog.unshift({ id:uid(), mangaId:m.id, title:m.title, type:m.type, oldCh:oldLatest, newCh:chLatest, cover:m.cover||'', time:Date.now(), read:false });
      saveLog();
    }
    showToast('Saved âœ“');
  } else {
    let cover = '';
    let seriesStatus = 'ongoing';
    if (mdId) {
      try {
        const d = await mdFetch(`/manga/${mdId}?includes[]=cover_art`);
        cover = coverUrl(d.data) || '';
        seriesStatus = d.data?.attributes?.status || 'ongoing';
      } catch {}
    }
    lib.push({
      id: uid(), title, mdId, cover, seriesStatus,
      type: document.getElementById('f-type').value,
      readingStatus: document.getElementById('f-rstatus').value,
      chRead, chLatest,
      hasNew: chLatest > chRead,
      addedAt: Date.now()
    });
    showToast(`"${title}" added! âœ“`);
  }

  saveLib(); closeModal(); renderLib();
}

// â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showToast(msg, type) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast' + (type==='err'?' err':'') + ' show';
  clearTimeout(t._t);
  t._t = setTimeout(() => t.classList.remove('show'), 3500);
}

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// Close on overlay click
document.getElementById('modal').addEventListener('click', e => { if (e.target===e.currentTarget) closeModal(); });
// Close results on outside click
document.addEventListener('click', e => {
  const r = document.getElementById('md-results');
  if (r && !r.contains(e.target) && e.target.id !== 'md-search') r.classList.remove('open');
});

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('panel-library').style.display = 'block';
renderLib();
// Auto-check every hour
setInterval(checkAllUpdates, 60 * 60 * 1000);
</script>
</body>
</html>
